---
title: "Defining a model in lgpr"
author: "Juho Timonen"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: yeti
vignette: >
  %\VignetteIndexEntry{Defining a model in lgpr}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#")
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))
```

```{r load}
require(lgpr)
require(ggplot2)
require(nlme)
```

# Introduction
The class `lgpmodel` represents an additive Gaussian process model. Such models
can be created in `lgpr` using the function `create_model()`, and they
can be fit by calling `sample_model()`. The easiest way, however, is probably
to use the `lgp()` function which wraps both `create_model()` and `sample_model()`
and has all the same arguments. The complete
information about these arguments is in the documentation, but here we review
the most common ones, i.e. `formula`, `data` and `prior`.

In this tutorial we focus on defining a model with
`create_model()`, and the same syntax applies to `lgp()`.

## Specifying data
The `data` argument to `lgp()` or `create_model()` should be a `data.frame`
where continuous variables have a numeric type and categorical variables
are factors.

Here we use the `Orthodont` data set from the `nlme` package.

```{r data1}
dat <- data.frame(Orthodont)
dat$Sex <- as.factor(as.character(dat$Sex))
dat$Subject <- as.factor(as.character(dat$Subject))
str(dat)
```


```{r data2, fig.width=6.5, fig.height=4.3}
plot_data(dat, x_name = "age", y_name = "distance", group_by = "Subject",
          color_by = "Sex") + xlab('Age (years)')
```

# Specifying the model formula
The `formula` argument to `lgp()` or `create_model()` specifies
the response variable, model components and covariates.

## A) Common formula syntax
Here we create a model with the continuous variable `age` and categorical variables `Subject` and `Sex` as predictors for `distance`. 
```{r data3, fig.width=6.1, fig.height=4.3}
model <- create_model(distance ~ age + age|Sex + age|Subject, dat, verbose = FALSE)
print(model)
```
The formula `distance ~ age + age|Sex + age|Subject` has the same format as for example in the `lme4` package, which uses linear mixed effect models. It creates a model with three components:

  1. the shared effect of age
  2. the sex-specific deviation from the shared age effect
  3. the subject-specific deviation from the shared age effect

If we wanted effects 2. and 3. to not depend on age, we could write the formula as just `distance ~ age + Sex + Subject`.

## B) Advanced formula syntax
The above formula was actually automatically converted to the more specific format `distance ~ gp(age) + gp(age)*zs(Sex) + gp(age)*zs(Subject)`. The `lgpr` package has this advanced syntax, because the common formula syntax of R is not
expressive enough for all kinds of components that our models can have.
Formulae specified using the advanced syntax consist of terms which can combine
the following expressions through addition and multiplication:

  * `gp(x)` specifies a standard GP with exponentiated quadratic kernel
  * `gp_ns(x)` specifies a GP with a nonstationary kernel
  * `gp_vm(x)` specifies a GP with a variance-masked kernel
  * `zs(z)` specifies a GP with zero-sum kernel
  * `categ(z)` specifies a GP with categorical kernel
  *  terms multiplied by `unc(z)` have uncertainty in their
  continuous covariate, so that each level of `z` introduces one uncertainty
  parameter
  * terms multiplied by `het(z)` are have heterogeneity in the effect of their
  continuous covariate, so that each level of `z` introduces one level-specific
  magnitude parameter

Above, `x` was used to denote any continuous and `z` any categorical variable.
Each term can contain at most one continuous variable. Components which contain `gp(x)`, `gp_ns(x)`, or `gp_vm(x)` and have `NaN` or `NA` in the data of `x` are automatically multiplied by a mask for the missing values.
  
# Specifying parameter priors
The `prior` argument to `lgp()` or `create_model()` specifies the prior
distribution for kernel hyperparameters and other model parameters. In above model, we did not speficy `prior`, so default priors were
used. Custom priors can be given as a named list, like here:
```{r data4, fig.width=6.1, fig.height=4.3}
prior <- list(
  alpha = normal(mu = 0, sigma = 1), # gaussian for magnitudes <alpha>
  ell = igam(shape = 5, scale = 5) # inverse gamma for lengthscales <ell>
)

model2 <- create_model(formula = distance ~ age + age|Sex + age|Subject, 
                       data = dat, 
                       prior = prior)
param_summary(model2)
```
Specifying the `prior` argument as a named list gave the same prior for
all parameters matching that name. If we wanted separate priors for example 
for each lengthscale parameter, we could specify `ell` itself as a list
with length 3.

```{r prior_sample, eval=FALSE, include=FALSE}
#To check whether a given prior makes sense, we can sample from the prior
#predictive distribution
prior_fit <- lgp(distance ~ age + age|Sex + age|Subject, dat,
           sample_f = TRUE,
           prior_only = TRUE,
           iter = 1000,
           refresh = 200,
           chains = 1)

#and compare the distribution of drawn "data" to the real data
#See more about predictive checks [here](https://cran.r-project.org/web/packages/bayesplot/vignettes/graphical-ppcs.html).
print(prior_fit)
ppc(prior_fit, dat)
```

```{r post_sample, eval = FALSE, include = FALSE}
# The model can the be fit by sampling the posterior. Here we only run one 
# chain, but it is recommended to run several.
fit <- lgp(distance ~ age + age|Sex + age|Subject, dat,
           iter = 1000,
           refresh = 250,
           chains = 1)
print(fit)
plot_pred(fit, t_name = "age", group_by = "Subject")
```

# When to not use default priors

It is not recommended to use default priors blindly. Rather, priors should
be specified according to the knowledge about the problem at hand, as in any
Bayesian analysis. In `lgpr` this is especially important when

* Using a non-Gaussian likelihood or otherwise setting `sample_f = TRUE`.
In this case the response variable is not
normalized, so the scale on which the data varies must be taken into
  account when defining priors of the signal magnitude parameters
\code{alpha} and possible noise parameters (`sigma`, `phi`,
`gamma`). Also it should be checked if `c_hat` is set in a
sensible way.
* Using a model that contains a `gp_ns(x)` or `gp_vm(x)`
expression in its formula. In this case the corresponding covariate
`x` is not normalized, and the prior for the input warping steepness
parameter `wrp` must be set according to the expected width of the
window in which the nonstationary effect of `x` occurs. By default,
the width of this window is about 36, which has been set assuming that
 the unit of `x` is months.
