/*
    lgpr is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    lgpr is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with lgpr.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.18.0

#include <stan/model/model_header.hpp>

namespace model_lgp_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_lgp");
    reader.add_event(4, 4, "include", "/chunks/license.stan");
    reader.add_event(4, 0, "start", "/chunks/license.stan");
    reader.add_event(18, 14, "end", "/chunks/license.stan");
    reader.add_event(18, 5, "restart", "model_lgp");
    reader.add_event(20, 7, "include", "/chunks/kernels_base.stan");
    reader.add_event(20, 0, "start", "/chunks/kernels_base.stan");
    reader.add_event(133, 113, "end", "/chunks/kernels_base.stan");
    reader.add_event(133, 8, "restart", "model_lgp");
    reader.add_event(133, 8, "include", "/chunks/define_prior.stan");
    reader.add_event(133, 0, "start", "/chunks/define_prior.stan");
    reader.add_event(187, 54, "end", "/chunks/define_prior.stan");
    reader.add_event(187, 9, "restart", "model_lgp");
    reader.add_event(367, 189, "include", "/chunks/additive_components.stan");
    reader.add_event(367, 0, "start", "/chunks/additive_components.stan");
    reader.add_event(431, 64, "end", "/chunks/additive_components.stan");
    reader.add_event(431, 190, "restart", "model_lgp");
    reader.add_event(437, 196, "include", "/chunks/priors.stan");
    reader.add_event(437, 0, "start", "/chunks/priors.stan");
    reader.add_event(509, 72, "end", "/chunks/priors.stan");
    reader.add_event(509, 197, "restart", "model_lgp");
    reader.add_event(544, 232, "include", "/chunks/kernel_matrices.stan");
    reader.add_event(544, 0, "start", "/chunks/kernel_matrices.stan");
    reader.add_event(621, 77, "end", "/chunks/kernel_matrices.stan");
    reader.add_event(621, 233, "restart", "model_lgp");
    reader.add_event(638, 250, "include", "/chunks/kernel_matrices.stan");
    reader.add_event(638, 0, "start", "/chunks/kernel_matrices.stan");
    reader.add_event(715, 77, "end", "/chunks/kernel_matrices.stan");
    reader.add_event(715, 251, "restart", "model_lgp");
    reader.add_event(728, 262, "end", "model_lgp");
    return reader;
}

template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
warp_input(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
               const T1__& a,
               const T2__& b,
               const T3__& c, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 23;
        int n_tot(0);
        (void) n_tot;  // dummy to suppress unused var warning

        stan::math::fill(n_tot, std::numeric_limits<int>::min());
        stan::math::assign(n_tot,num_elements(x));
        current_statement_begin__ = 24;
        validate_non_negative_index("w", "n_tot", n_tot);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  w(static_cast<Eigen::VectorXd::Index>(n_tot));
        (void) w;  // dummy to suppress unused var warning

        stan::math::initialize(w, DUMMY_VAR__);
        stan::math::fill(w,DUMMY_VAR__);
        stan::math::assign(w,multiply((2 * c),add(-(0.5),elt_divide(rep_vector(1,n_tot),add(1,stan::math::exp(multiply(-(a),subtract(x,b))))))));


        current_statement_begin__ = 25;
        return stan::math::promote_scalar<fun_return_scalar_t__>(w);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct warp_input_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
               const T1__& a,
               const T2__& b,
               const T3__& c, std::ostream* pstream__) const {
        return warp_input(x, a, b, c, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,1>
var_mask(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
             const T1__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 30;
        int n_tot(0);
        (void) n_tot;  // dummy to suppress unused var warning

        stan::math::fill(n_tot, std::numeric_limits<int>::min());
        stan::math::assign(n_tot,num_elements(x));
        current_statement_begin__ = 31;
        validate_non_negative_index("s", "n_tot", n_tot);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(n_tot));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);
        stan::math::assign(s,elt_divide(rep_vector(1,n_tot),add(1,stan::math::exp(multiply(-(a),x)))));


        current_statement_begin__ = 32;
        return stan::math::promote_scalar<fun_return_scalar_t__>(s);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct var_mask_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
             const T1__& a, std::ostream* pstream__) const {
        return var_mask(x, a, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,1>
get_x_tilde(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x_disAge,
                const Eigen::Matrix<T1__, Eigen::Dynamic,1>& T_onset,
                const Eigen::Matrix<T2__, Eigen::Dynamic,1>& T_observed,
                const std::vector<std::vector<int> >& mapping,
                const std::vector<int>& lengths, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 37;
        int n_tot(0);
        (void) n_tot;  // dummy to suppress unused var warning

        stan::math::fill(n_tot, std::numeric_limits<int>::min());
        stan::math::assign(n_tot,num_elements(x_disAge));
        current_statement_begin__ = 38;
        int N_cases(0);
        (void) N_cases;  // dummy to suppress unused var warning

        stan::math::fill(N_cases, std::numeric_limits<int>::min());
        stan::math::assign(N_cases,num_elements(lengths));
        current_statement_begin__ = 39;
        validate_non_negative_index("x_tilde", "n_tot", n_tot);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  x_tilde(static_cast<Eigen::VectorXd::Index>(n_tot));
        (void) x_tilde;  // dummy to suppress unused var warning

        stan::math::initialize(x_tilde, DUMMY_VAR__);
        stan::math::fill(x_tilde,DUMMY_VAR__);
        stan::math::assign(x_tilde,rep_vector(0.0,n_tot));


        current_statement_begin__ = 40;
        for (int k = 1; k <= N_cases; ++k) {
            {
            current_statement_begin__ = 41;
            validate_non_negative_index("inds", "get_base1(lengths,k,\"lengths\",1)", get_base1(lengths,k,"lengths",1));
            vector<int> inds(get_base1(lengths,k,"lengths",1), 0);
            stan::math::fill(inds, std::numeric_limits<int>::min());
            stan::math::assign(inds,stan::model::rvalue(mapping, stan::model::cons_list(stan::model::index_uni(k), stan::model::cons_list(stan::model::index_min_max(1, get_base1(lengths,k,"lengths",1)), stan::model::nil_index_list())), "mapping"));


            current_statement_begin__ = 42;
            stan::model::assign(x_tilde, 
                        stan::model::cons_list(stan::model::index_multi(inds), stan::model::nil_index_list()), 
                        subtract(add(stan::model::rvalue(x_disAge, stan::model::cons_list(stan::model::index_multi(inds), stan::model::nil_index_list()), "x_disAge"),get_base1(T_observed,k,"T_observed",1)),get_base1(T_onset,k,"T_onset",1)), 
                        "assigning variable x_tilde");
            }
        }
        current_statement_begin__ = 44;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_tilde);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_x_tilde_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x_disAge,
                const Eigen::Matrix<T1__, Eigen::Dynamic,1>& T_onset,
                const Eigen::Matrix<T2__, Eigen::Dynamic,1>& T_observed,
                const std::vector<std::vector<int> >& mapping,
                const std::vector<int>& lengths, std::ostream* pstream__) const {
        return get_x_tilde(x_disAge, T_onset, T_observed, mapping, lengths, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
K_cat(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x1,
          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& x2, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 49;
        int n1(0);
        (void) n1;  // dummy to suppress unused var warning

        stan::math::fill(n1, std::numeric_limits<int>::min());
        stan::math::assign(n1,num_elements(x1));
        current_statement_begin__ = 50;
        int n2(0);
        (void) n2;  // dummy to suppress unused var warning

        stan::math::fill(n2, std::numeric_limits<int>::min());
        stan::math::assign(n2,num_elements(x2));
        current_statement_begin__ = 51;
        validate_non_negative_index("K", "n1", n1);
        validate_non_negative_index("K", "n2", n2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(n1),static_cast<Eigen::VectorXd::Index>(n2));
        (void) K;  // dummy to suppress unused var warning

        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K,DUMMY_VAR__);


        current_statement_begin__ = 52;
        for (int i = 1; i <= n1; ++i) {

            current_statement_begin__ = 53;
            for (int j = 1; j <= n2; ++j) {

                current_statement_begin__ = 54;
                stan::model::assign(K, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            logical_eq(get_base1(x1,i,"x1",1),get_base1(x2,j,"x2",1)), 
                            "assigning variable K");
            }
        }
        current_statement_begin__ = 57;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct K_cat_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x1,
          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& x2, std::ostream* pstream__) const {
        return K_cat(x1, x2, pstream__);
    }
};

Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
K_bin_int(const std::vector<int>& x1,
              const std::vector<int>& x2,
              const int& c, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 63;
        int n1(0);
        (void) n1;  // dummy to suppress unused var warning

        stan::math::fill(n1, std::numeric_limits<int>::min());
        stan::math::assign(n1,num_elements(x1));
        current_statement_begin__ = 64;
        int n2(0);
        (void) n2;  // dummy to suppress unused var warning

        stan::math::fill(n2, std::numeric_limits<int>::min());
        stan::math::assign(n2,num_elements(x2));
        current_statement_begin__ = 65;
        validate_non_negative_index("K", "n1", n1);
        validate_non_negative_index("K", "n2", n2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(n1),static_cast<Eigen::VectorXd::Index>(n2));
        (void) K;  // dummy to suppress unused var warning

        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K,DUMMY_VAR__);


        current_statement_begin__ = 66;
        for (int i = 1; i <= n1; ++i) {

            current_statement_begin__ = 67;
            for (int j = 1; j <= n2; ++j) {

                current_statement_begin__ = 68;
                stan::model::assign(K, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            (logical_eq(get_base1(x1,i,"x1",1),c) * logical_eq(get_base1(x2,j,"x2",1),c)), 
                            "assigning variable K");
            }
        }
        current_statement_begin__ = 71;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct K_bin_int_functor__ {
            Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<int>& x1,
              const std::vector<int>& x2,
              const int& c, std::ostream* pstream__) const {
        return K_bin_int(x1, x2, c, pstream__);
    }
};

template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
K_bin_real(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x1,
               const Eigen::Matrix<T1__, Eigen::Dynamic,1>& x2,
               const int& c, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 76;
        int n1(0);
        (void) n1;  // dummy to suppress unused var warning

        stan::math::fill(n1, std::numeric_limits<int>::min());
        stan::math::assign(n1,num_elements(x1));
        current_statement_begin__ = 77;
        int n2(0);
        (void) n2;  // dummy to suppress unused var warning

        stan::math::fill(n2, std::numeric_limits<int>::min());
        stan::math::assign(n2,num_elements(x2));
        current_statement_begin__ = 78;
        validate_non_negative_index("K", "n1", n1);
        validate_non_negative_index("K", "n2", n2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  K(static_cast<Eigen::VectorXd::Index>(n1),static_cast<Eigen::VectorXd::Index>(n2));
        (void) K;  // dummy to suppress unused var warning

        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K,DUMMY_VAR__);


        current_statement_begin__ = 79;
        for (int i = 1; i <= n1; ++i) {

            current_statement_begin__ = 80;
            for (int j = 1; j <= n2; ++j) {

                current_statement_begin__ = 81;
                stan::model::assign(K, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            (logical_eq(get_base1(x1,i,"x1",1),c) * logical_eq(get_base1(x2,j,"x2",1),c)), 
                            "assigning variable K");
            }
        }
        current_statement_begin__ = 84;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct K_bin_real_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x1,
               const Eigen::Matrix<T1__, Eigen::Dynamic,1>& x2,
               const int& c, std::ostream* pstream__) const {
        return K_bin_real(x1, x2, c, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
K_var_mask(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x_tilde,
               const T1__& stp,
               const std::vector<T2__>& vm_params, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 89;
        int n(0);
        (void) n;  // dummy to suppress unused var warning

        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,num_elements(x_tilde));
        current_statement_begin__ = 90;
        local_scalar_t__ a;
        (void) a;  // dummy to suppress unused var warning

        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a,DUMMY_VAR__);
        stan::math::assign(a,(stp * get_base1(vm_params,2,"vm_params",1)));
        current_statement_begin__ = 91;
        local_scalar_t__ h;
        (void) h;  // dummy to suppress unused var warning

        stan::math::initialize(h, DUMMY_VAR__);
        stan::math::fill(h,DUMMY_VAR__);
        stan::math::assign(h,get_base1(vm_params,1,"vm_params",1));
        current_statement_begin__ = 92;
        local_scalar_t__ r;
        (void) r;  // dummy to suppress unused var warning

        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r,DUMMY_VAR__);
        stan::math::assign(r,((1 / a) * stan::math::log((h / (1 - h)))));
        current_statement_begin__ = 93;
        validate_non_negative_index("s", "n", n);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  s(static_cast<Eigen::VectorXd::Index>(n));
        (void) s;  // dummy to suppress unused var warning

        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s,DUMMY_VAR__);
        stan::math::assign(s,var_mask(subtract(x_tilde,r),a, pstream__));
        current_statement_begin__ = 94;
        validate_non_negative_index("MASK", "n", n);
        validate_non_negative_index("MASK", "n", n);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  MASK(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
        (void) MASK;  // dummy to suppress unused var warning

        stan::math::initialize(MASK, DUMMY_VAR__);
        stan::math::fill(MASK,DUMMY_VAR__);
        stan::math::assign(MASK,tcrossprod(to_matrix(s)));


        current_statement_begin__ = 95;
        return stan::math::promote_scalar<fun_return_scalar_t__>(MASK);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct K_var_mask_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x_tilde,
               const T1__& stp,
               const std::vector<T2__>& vm_params, std::ostream* pstream__) const {
        return K_var_mask(x_tilde, stp, vm_params, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
K_beta(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& beta,
           const std::vector<int>& row_to_caseID, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 100;
        int n(0);
        (void) n;  // dummy to suppress unused var warning

        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,num_elements(row_to_caseID));
        current_statement_begin__ = 101;
        int i_caseID(0);
        (void) i_caseID;  // dummy to suppress unused var warning

        stan::math::fill(i_caseID, std::numeric_limits<int>::min());
        stan::math::assign(i_caseID,0);
        current_statement_begin__ = 102;
        int j_caseID(0);
        (void) j_caseID;  // dummy to suppress unused var warning

        stan::math::fill(j_caseID, std::numeric_limits<int>::min());
        stan::math::assign(j_caseID,0);
        current_statement_begin__ = 103;
        local_scalar_t__ tmp;
        (void) tmp;  // dummy to suppress unused var warning

        stan::math::initialize(tmp, DUMMY_VAR__);
        stan::math::fill(tmp,DUMMY_VAR__);
        current_statement_begin__ = 104;
        validate_non_negative_index("BETA", "n", n);
        validate_non_negative_index("BETA", "n", n);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  BETA(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
        (void) BETA;  // dummy to suppress unused var warning

        stan::math::initialize(BETA, DUMMY_VAR__);
        stan::math::fill(BETA,DUMMY_VAR__);


        current_statement_begin__ = 105;
        for (int i = 1; i <= (n - 1); ++i) {

            current_statement_begin__ = 106;
            stan::math::assign(i_caseID, get_base1(row_to_caseID,i,"row_to_caseID",1));
            current_statement_begin__ = 107;
            for (int j = (i + 1); j <= n; ++j) {

                current_statement_begin__ = 108;
                stan::math::assign(j_caseID, get_base1(row_to_caseID,j,"row_to_caseID",1));
                current_statement_begin__ = 109;
                if (as_bool(logical_gt((i_caseID * j_caseID),0))) {

                    current_statement_begin__ = 110;
                    stan::math::assign(tmp, stan::math::sqrt((get_base1(beta,i_caseID,"beta",1) * get_base1(beta,j_caseID,"beta",1))));
                } else {

                    current_statement_begin__ = 112;
                    stan::math::assign(tmp, 0);
                }
                current_statement_begin__ = 114;
                stan::model::assign(BETA, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            tmp, 
                            "assigning variable BETA");
                current_statement_begin__ = 115;
                stan::model::assign(BETA, 
                            stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            tmp, 
                            "assigning variable BETA");
            }
            current_statement_begin__ = 118;
            if (as_bool(logical_gt(i_caseID,0))) {

                current_statement_begin__ = 119;
                stan::model::assign(BETA, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            get_base1(beta,i_caseID,"beta",1), 
                            "assigning variable BETA");
            } else {

                current_statement_begin__ = 121;
                stan::model::assign(BETA, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            0, 
                            "assigning variable BETA");
            }
        }
        current_statement_begin__ = 125;
        stan::math::assign(i_caseID, get_base1(row_to_caseID,n,"row_to_caseID",1));
        current_statement_begin__ = 126;
        if (as_bool(logical_gt(i_caseID,0))) {

            current_statement_begin__ = 127;
            stan::model::assign(BETA, 
                        stan::model::cons_list(stan::model::index_uni(n), stan::model::cons_list(stan::model::index_uni(n), stan::model::nil_index_list())), 
                        get_base1(beta,i_caseID,"beta",1), 
                        "assigning variable BETA");
        } else {

            current_statement_begin__ = 129;
            stan::model::assign(BETA, 
                        stan::model::cons_list(stan::model::index_uni(n), stan::model::cons_list(stan::model::index_uni(n), stan::model::nil_index_list())), 
                        0, 
                        "assigning variable BETA");
        }
        current_statement_begin__ = 131;
        return stan::math::promote_scalar<fun_return_scalar_t__>(BETA);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct K_beta_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& beta,
           const std::vector<int>& row_to_caseID, std::ostream* pstream__) const {
        return K_beta(beta, row_to_caseID, pstream__);
    }
};

template <typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
log_prior(const T0__& x,
              const std::vector<int>& types,
              const std::vector<T2__>& hp, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 151;
        local_scalar_t__ lp;
        (void) lp;  // dummy to suppress unused var warning

        stan::math::initialize(lp, DUMMY_VAR__);
        stan::math::fill(lp,DUMMY_VAR__);
        current_statement_begin__ = 152;
        local_scalar_t__ a;
        (void) a;  // dummy to suppress unused var warning

        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a,DUMMY_VAR__);
        stan::math::assign(a,get_base1(hp,1,"hp",1));
        current_statement_begin__ = 153;
        local_scalar_t__ b;
        (void) b;  // dummy to suppress unused var warning

        stan::math::initialize(b, DUMMY_VAR__);
        stan::math::fill(b,DUMMY_VAR__);
        stan::math::assign(b,get_base1(hp,2,"hp",1));
        current_statement_begin__ = 154;
        local_scalar_t__ c;
        (void) c;  // dummy to suppress unused var warning

        stan::math::initialize(c, DUMMY_VAR__);
        stan::math::fill(c,DUMMY_VAR__);
        stan::math::assign(c,get_base1(hp,3,"hp",1));
        current_statement_begin__ = 155;
        local_scalar_t__ theta;
        (void) theta;  // dummy to suppress unused var warning

        stan::math::initialize(theta, DUMMY_VAR__);
        stan::math::fill(theta,DUMMY_VAR__);


        current_statement_begin__ = 158;
        if (as_bool(logical_eq(get_base1(types,2,"types",1),0))) {

            current_statement_begin__ = 159;
            stan::math::assign(lp, 0);
            current_statement_begin__ = 160;
            stan::math::assign(theta, x);
        } else if (as_bool(logical_eq(get_base1(types,2,"types",1),1))) {

            current_statement_begin__ = 162;
            stan::math::assign(lp, stan::math::log(stan::math::fabs((2 * x))));
            current_statement_begin__ = 163;
            stan::math::assign(theta, square(x));
        } else {

            current_statement_begin__ = 165;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "invalid value of types[2]!";
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 169;
        if (as_bool(logical_eq(get_base1(types,1,"types",1),1))) {

        } else if (as_bool(logical_eq(get_base1(types,1,"types",1),2))) {

            current_statement_begin__ = 172;
            stan::math::assign(lp, (lp + normal_log(theta,a,b)));
        } else if (as_bool(logical_eq(get_base1(types,1,"types",1),3))) {

            current_statement_begin__ = 174;
            stan::math::assign(lp, (lp + student_t_log(theta,a,0,b)));
        } else if (as_bool(logical_eq(get_base1(types,1,"types",1),4))) {

            current_statement_begin__ = 176;
            stan::math::assign(lp, (lp + gamma_log(theta,a,b)));
        } else if (as_bool(logical_eq(get_base1(types,1,"types",1),5))) {

            current_statement_begin__ = 178;
            stan::math::assign(lp, (lp + inv_gamma_log(theta,a,b)));
        } else if (as_bool(logical_eq(get_base1(types,1,"types",1),6))) {

            current_statement_begin__ = 180;
            stan::math::assign(lp, (lp + lognormal_log(theta,a,b)));
        } else {

            current_statement_begin__ = 182;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "types[1] must be an integer between 1 and 6; found =";
            errmsg_stream__ << get_base1(types,1,"types",1);
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 186;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lp);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct log_prior_functor__ {
    template <typename T0__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T2__>::type
    operator()(const T0__& x,
              const std::vector<int>& types,
              const std::vector<T2__>& hp, std::ostream* pstream__) const {
        return log_prior(x, types, hp, pstream__);
    }
};

#include <meta_header.hpp>
 class model_lgp : public prob_grad {
private:
    int N_tot;
    int N_cases;
    int d;
    int n;
    int n_test;
    vector<vector_d> X;
    vector<int> X_id;
    vector<int> X_notnan;
    vector_d y;
    vector<int> y_int;
    int LH;
    vector<int> D;
    int UNCRT;
    int HMGNS;
    vector<vector<int> > t_ID;
    vector<vector<int> > t_A;
    vector<vector<int> > t_D;
    vector<vector<int> > t_CNT;
    vector<vector<int> > t_CAT;
    vector<vector<int> > t_OFS;
    vector<int> t_SIG;
    vector<int> t_PHI;
    vector<vector<int> > t_ONS;
    vector<vector<double> > p_ID;
    vector<vector<double> > p_A;
    vector<vector<double> > p_D;
    vector<vector<double> > p_CNT;
    vector<vector<double> > p_CAT;
    vector<vector<double> > p_OFS;
    vector<double> p_SIG;
    vector<double> p_PHI;
    vector<double> p_BET;
    vector<vector<double> > p_ONS;
    int M_max;
    vector<vector<int> > caseID_to_rows;
    vector<int> row_to_caseID;
    vector<int> caseID_nrows;
    vector_d T_observed;
    vector<vector_d> L_ons;
    vector<vector_d> U_ons;
    int backwards;
    double DELTA;
    double C_hat;
    vector<int> HS;
    int F_is_sampled;
    int USE_VAR_MASK;
    vector<double> vm_params;
    int cat_interact_kernel;
    int n_tot;
    int nf;
    int sum_D;
    vector<matrix_d> KF;
    vector<double> x_age;
    vector_d mu;
public:
    model_lgp(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_lgp(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;

        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_lgp_namespace::model_lgp";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 193;
            context__.validate_dims("data initialization", "N_tot", "int", context__.to_vec());
            N_tot = int(0);
            vals_i__ = context__.vals_i("N_tot");
            pos__ = 0;
            N_tot = vals_i__[pos__++];
            current_statement_begin__ = 194;
            context__.validate_dims("data initialization", "N_cases", "int", context__.to_vec());
            N_cases = int(0);
            vals_i__ = context__.vals_i("N_cases");
            pos__ = 0;
            N_cases = vals_i__[pos__++];
            current_statement_begin__ = 195;
            context__.validate_dims("data initialization", "d", "int", context__.to_vec());
            d = int(0);
            vals_i__ = context__.vals_i("d");
            pos__ = 0;
            d = vals_i__[pos__++];
            current_statement_begin__ = 196;
            context__.validate_dims("data initialization", "n", "int", context__.to_vec());
            n = int(0);
            vals_i__ = context__.vals_i("n");
            pos__ = 0;
            n = vals_i__[pos__++];
            current_statement_begin__ = 197;
            context__.validate_dims("data initialization", "n_test", "int", context__.to_vec());
            n_test = int(0);
            vals_i__ = context__.vals_i("n_test");
            pos__ = 0;
            n_test = vals_i__[pos__++];
            current_statement_begin__ = 201;
            validate_non_negative_index("X", "d", d);
            validate_non_negative_index("X", "(n + n_test)", (n + n_test));
            context__.validate_dims("data initialization", "X", "vector_d", context__.to_vec(d,(n + n_test)));
            validate_non_negative_index("X", "d", d);
            validate_non_negative_index("X", "(n + n_test)", (n + n_test));
            X = std::vector<vector_d>(d,vector_d(static_cast<Eigen::VectorXd::Index>((n + n_test))));
            vals_r__ = context__.vals_r("X");
            pos__ = 0;
            size_t X_i_vec_lim__ = (n + n_test);
            for (size_t i_vec__ = 0; i_vec__ < X_i_vec_lim__; ++i_vec__) {
                size_t X_limit_0__ = d;
                for (size_t i_0__ = 0; i_0__ < X_limit_0__; ++i_0__) {
                    X[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 202;
            validate_non_negative_index("X_id", "(n + n_test)", (n + n_test));
            context__.validate_dims("data initialization", "X_id", "int", context__.to_vec((n + n_test)));
            validate_non_negative_index("X_id", "(n + n_test)", (n + n_test));
            X_id = std::vector<int>((n + n_test),int(0));
            vals_i__ = context__.vals_i("X_id");
            pos__ = 0;
            size_t X_id_limit_0__ = (n + n_test);
            for (size_t i_0__ = 0; i_0__ < X_id_limit_0__; ++i_0__) {
                X_id[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 203;
            validate_non_negative_index("X_notnan", "(n + n_test)", (n + n_test));
            context__.validate_dims("data initialization", "X_notnan", "int", context__.to_vec((n + n_test)));
            validate_non_negative_index("X_notnan", "(n + n_test)", (n + n_test));
            X_notnan = std::vector<int>((n + n_test),int(0));
            vals_i__ = context__.vals_i("X_notnan");
            pos__ = 0;
            size_t X_notnan_limit_0__ = (n + n_test);
            for (size_t i_0__ = 0; i_0__ < X_notnan_limit_0__; ++i_0__) {
                X_notnan[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 204;
            validate_non_negative_index("y", "n", n);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(n));
            validate_non_negative_index("y", "n", n);
            y = vector_d(static_cast<Eigen::VectorXd::Index>(n));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_i_vec_lim__ = n;
            for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
                y[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 205;
            validate_non_negative_index("y_int", "n", n);
            context__.validate_dims("data initialization", "y_int", "int", context__.to_vec(n));
            validate_non_negative_index("y_int", "n", n);
            y_int = std::vector<int>(n,int(0));
            vals_i__ = context__.vals_i("y_int");
            pos__ = 0;
            size_t y_int_limit_0__ = n;
            for (size_t i_0__ = 0; i_0__ < y_int_limit_0__; ++i_0__) {
                y_int[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 208;
            context__.validate_dims("data initialization", "LH", "int", context__.to_vec());
            LH = int(0);
            vals_i__ = context__.vals_i("LH");
            pos__ = 0;
            LH = vals_i__[pos__++];
            current_statement_begin__ = 217;
            validate_non_negative_index("D", "6", 6);
            context__.validate_dims("data initialization", "D", "int", context__.to_vec(6));
            validate_non_negative_index("D", "6", 6);
            D = std::vector<int>(6,int(0));
            vals_i__ = context__.vals_i("D");
            pos__ = 0;
            size_t D_limit_0__ = 6;
            for (size_t i_0__ = 0; i_0__ < D_limit_0__; ++i_0__) {
                D[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 220;
            context__.validate_dims("data initialization", "UNCRT", "int", context__.to_vec());
            UNCRT = int(0);
            vals_i__ = context__.vals_i("UNCRT");
            pos__ = 0;
            UNCRT = vals_i__[pos__++];
            current_statement_begin__ = 221;
            context__.validate_dims("data initialization", "HMGNS", "int", context__.to_vec());
            HMGNS = int(0);
            vals_i__ = context__.vals_i("HMGNS");
            pos__ = 0;
            HMGNS = vals_i__[pos__++];
            current_statement_begin__ = 224;
            validate_non_negative_index("t_ID", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            validate_non_negative_index("t_ID", "4", 4);
            context__.validate_dims("data initialization", "t_ID", "int", context__.to_vec(get_base1(D,1,"D",1),4));
            validate_non_negative_index("t_ID", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            validate_non_negative_index("t_ID", "4", 4);
            t_ID = std::vector<std::vector<int> >(get_base1(D,1,"D",1),std::vector<int>(4,int(0)));
            vals_i__ = context__.vals_i("t_ID");
            pos__ = 0;
            size_t t_ID_limit_1__ = 4;
            for (size_t i_1__ = 0; i_1__ < t_ID_limit_1__; ++i_1__) {
                size_t t_ID_limit_0__ = get_base1(D,1,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_ID_limit_0__; ++i_0__) {
                    t_ID[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 225;
            validate_non_negative_index("t_A", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            validate_non_negative_index("t_A", "4", 4);
            context__.validate_dims("data initialization", "t_A", "int", context__.to_vec(get_base1(D,2,"D",1),4));
            validate_non_negative_index("t_A", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            validate_non_negative_index("t_A", "4", 4);
            t_A = std::vector<std::vector<int> >(get_base1(D,2,"D",1),std::vector<int>(4,int(0)));
            vals_i__ = context__.vals_i("t_A");
            pos__ = 0;
            size_t t_A_limit_1__ = 4;
            for (size_t i_1__ = 0; i_1__ < t_A_limit_1__; ++i_1__) {
                size_t t_A_limit_0__ = get_base1(D,2,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_A_limit_0__; ++i_0__) {
                    t_A[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 226;
            validate_non_negative_index("t_D", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            validate_non_negative_index("t_D", "6", 6);
            context__.validate_dims("data initialization", "t_D", "int", context__.to_vec(get_base1(D,3,"D",1),6));
            validate_non_negative_index("t_D", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            validate_non_negative_index("t_D", "6", 6);
            t_D = std::vector<std::vector<int> >(get_base1(D,3,"D",1),std::vector<int>(6,int(0)));
            vals_i__ = context__.vals_i("t_D");
            pos__ = 0;
            size_t t_D_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < t_D_limit_1__; ++i_1__) {
                size_t t_D_limit_0__ = get_base1(D,3,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_D_limit_0__; ++i_0__) {
                    t_D[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 227;
            validate_non_negative_index("t_CNT", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            validate_non_negative_index("t_CNT", "4", 4);
            context__.validate_dims("data initialization", "t_CNT", "int", context__.to_vec(get_base1(D,4,"D",1),4));
            validate_non_negative_index("t_CNT", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            validate_non_negative_index("t_CNT", "4", 4);
            t_CNT = std::vector<std::vector<int> >(get_base1(D,4,"D",1),std::vector<int>(4,int(0)));
            vals_i__ = context__.vals_i("t_CNT");
            pos__ = 0;
            size_t t_CNT_limit_1__ = 4;
            for (size_t i_1__ = 0; i_1__ < t_CNT_limit_1__; ++i_1__) {
                size_t t_CNT_limit_0__ = get_base1(D,4,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_CNT_limit_0__; ++i_0__) {
                    t_CNT[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 228;
            validate_non_negative_index("t_CAT", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            validate_non_negative_index("t_CAT", "4", 4);
            context__.validate_dims("data initialization", "t_CAT", "int", context__.to_vec(get_base1(D,5,"D",1),4));
            validate_non_negative_index("t_CAT", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            validate_non_negative_index("t_CAT", "4", 4);
            t_CAT = std::vector<std::vector<int> >(get_base1(D,5,"D",1),std::vector<int>(4,int(0)));
            vals_i__ = context__.vals_i("t_CAT");
            pos__ = 0;
            size_t t_CAT_limit_1__ = 4;
            for (size_t i_1__ = 0; i_1__ < t_CAT_limit_1__; ++i_1__) {
                size_t t_CAT_limit_0__ = get_base1(D,5,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_CAT_limit_0__; ++i_0__) {
                    t_CAT[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 229;
            validate_non_negative_index("t_OFS", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
            validate_non_negative_index("t_OFS", "2", 2);
            context__.validate_dims("data initialization", "t_OFS", "int", context__.to_vec(get_base1(D,6,"D",1),2));
            validate_non_negative_index("t_OFS", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
            validate_non_negative_index("t_OFS", "2", 2);
            t_OFS = std::vector<std::vector<int> >(get_base1(D,6,"D",1),std::vector<int>(2,int(0)));
            vals_i__ = context__.vals_i("t_OFS");
            pos__ = 0;
            size_t t_OFS_limit_1__ = 2;
            for (size_t i_1__ = 0; i_1__ < t_OFS_limit_1__; ++i_1__) {
                size_t t_OFS_limit_0__ = get_base1(D,6,"D",1);
                for (size_t i_0__ = 0; i_0__ < t_OFS_limit_0__; ++i_0__) {
                    t_OFS[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 230;
            validate_non_negative_index("t_SIG", "2", 2);
            context__.validate_dims("data initialization", "t_SIG", "int", context__.to_vec(2));
            validate_non_negative_index("t_SIG", "2", 2);
            t_SIG = std::vector<int>(2,int(0));
            vals_i__ = context__.vals_i("t_SIG");
            pos__ = 0;
            size_t t_SIG_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < t_SIG_limit_0__; ++i_0__) {
                t_SIG[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 231;
            validate_non_negative_index("t_PHI", "2", 2);
            context__.validate_dims("data initialization", "t_PHI", "int", context__.to_vec(2));
            validate_non_negative_index("t_PHI", "2", 2);
            t_PHI = std::vector<int>(2,int(0));
            vals_i__ = context__.vals_i("t_PHI");
            pos__ = 0;
            size_t t_PHI_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < t_PHI_limit_0__; ++i_0__) {
                t_PHI[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 232;
            validate_non_negative_index("t_ONS", "N_cases", N_cases);
            validate_non_negative_index("t_ONS", "2", 2);
            context__.validate_dims("data initialization", "t_ONS", "int", context__.to_vec(N_cases,2));
            validate_non_negative_index("t_ONS", "N_cases", N_cases);
            validate_non_negative_index("t_ONS", "2", 2);
            t_ONS = std::vector<std::vector<int> >(N_cases,std::vector<int>(2,int(0)));
            vals_i__ = context__.vals_i("t_ONS");
            pos__ = 0;
            size_t t_ONS_limit_1__ = 2;
            for (size_t i_1__ = 0; i_1__ < t_ONS_limit_1__; ++i_1__) {
                size_t t_ONS_limit_0__ = N_cases;
                for (size_t i_0__ = 0; i_0__ < t_ONS_limit_0__; ++i_0__) {
                    t_ONS[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 235;
            validate_non_negative_index("p_ID", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            validate_non_negative_index("p_ID", "6", 6);
            context__.validate_dims("data initialization", "p_ID", "double", context__.to_vec(get_base1(D,1,"D",1),6));
            validate_non_negative_index("p_ID", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            validate_non_negative_index("p_ID", "6", 6);
            p_ID = std::vector<std::vector<double> >(get_base1(D,1,"D",1),std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("p_ID");
            pos__ = 0;
            size_t p_ID_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < p_ID_limit_1__; ++i_1__) {
                size_t p_ID_limit_0__ = get_base1(D,1,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_ID_limit_0__; ++i_0__) {
                    p_ID[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 236;
            validate_non_negative_index("p_A", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            validate_non_negative_index("p_A", "6", 6);
            context__.validate_dims("data initialization", "p_A", "double", context__.to_vec(get_base1(D,2,"D",1),6));
            validate_non_negative_index("p_A", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            validate_non_negative_index("p_A", "6", 6);
            p_A = std::vector<std::vector<double> >(get_base1(D,2,"D",1),std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("p_A");
            pos__ = 0;
            size_t p_A_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < p_A_limit_1__; ++i_1__) {
                size_t p_A_limit_0__ = get_base1(D,2,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_A_limit_0__; ++i_0__) {
                    p_A[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 237;
            validate_non_negative_index("p_D", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            validate_non_negative_index("p_D", "9", 9);
            context__.validate_dims("data initialization", "p_D", "double", context__.to_vec(get_base1(D,3,"D",1),9));
            validate_non_negative_index("p_D", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            validate_non_negative_index("p_D", "9", 9);
            p_D = std::vector<std::vector<double> >(get_base1(D,3,"D",1),std::vector<double>(9,double(0)));
            vals_r__ = context__.vals_r("p_D");
            pos__ = 0;
            size_t p_D_limit_1__ = 9;
            for (size_t i_1__ = 0; i_1__ < p_D_limit_1__; ++i_1__) {
                size_t p_D_limit_0__ = get_base1(D,3,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_D_limit_0__; ++i_0__) {
                    p_D[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 238;
            validate_non_negative_index("p_CNT", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            validate_non_negative_index("p_CNT", "6", 6);
            context__.validate_dims("data initialization", "p_CNT", "double", context__.to_vec(get_base1(D,4,"D",1),6));
            validate_non_negative_index("p_CNT", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            validate_non_negative_index("p_CNT", "6", 6);
            p_CNT = std::vector<std::vector<double> >(get_base1(D,4,"D",1),std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("p_CNT");
            pos__ = 0;
            size_t p_CNT_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < p_CNT_limit_1__; ++i_1__) {
                size_t p_CNT_limit_0__ = get_base1(D,4,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_CNT_limit_0__; ++i_0__) {
                    p_CNT[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 239;
            validate_non_negative_index("p_CAT", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            validate_non_negative_index("p_CAT", "6", 6);
            context__.validate_dims("data initialization", "p_CAT", "double", context__.to_vec(get_base1(D,5,"D",1),6));
            validate_non_negative_index("p_CAT", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            validate_non_negative_index("p_CAT", "6", 6);
            p_CAT = std::vector<std::vector<double> >(get_base1(D,5,"D",1),std::vector<double>(6,double(0)));
            vals_r__ = context__.vals_r("p_CAT");
            pos__ = 0;
            size_t p_CAT_limit_1__ = 6;
            for (size_t i_1__ = 0; i_1__ < p_CAT_limit_1__; ++i_1__) {
                size_t p_CAT_limit_0__ = get_base1(D,5,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_CAT_limit_0__; ++i_0__) {
                    p_CAT[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 240;
            validate_non_negative_index("p_OFS", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
            validate_non_negative_index("p_OFS", "3", 3);
            context__.validate_dims("data initialization", "p_OFS", "double", context__.to_vec(get_base1(D,6,"D",1),3));
            validate_non_negative_index("p_OFS", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
            validate_non_negative_index("p_OFS", "3", 3);
            p_OFS = std::vector<std::vector<double> >(get_base1(D,6,"D",1),std::vector<double>(3,double(0)));
            vals_r__ = context__.vals_r("p_OFS");
            pos__ = 0;
            size_t p_OFS_limit_1__ = 3;
            for (size_t i_1__ = 0; i_1__ < p_OFS_limit_1__; ++i_1__) {
                size_t p_OFS_limit_0__ = get_base1(D,6,"D",1);
                for (size_t i_0__ = 0; i_0__ < p_OFS_limit_0__; ++i_0__) {
                    p_OFS[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 241;
            validate_non_negative_index("p_SIG", "3", 3);
            context__.validate_dims("data initialization", "p_SIG", "double", context__.to_vec(3));
            validate_non_negative_index("p_SIG", "3", 3);
            p_SIG = std::vector<double>(3,double(0));
            vals_r__ = context__.vals_r("p_SIG");
            pos__ = 0;
            size_t p_SIG_limit_0__ = 3;
            for (size_t i_0__ = 0; i_0__ < p_SIG_limit_0__; ++i_0__) {
                p_SIG[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 242;
            validate_non_negative_index("p_PHI", "3", 3);
            context__.validate_dims("data initialization", "p_PHI", "double", context__.to_vec(3));
            validate_non_negative_index("p_PHI", "3", 3);
            p_PHI = std::vector<double>(3,double(0));
            vals_r__ = context__.vals_r("p_PHI");
            pos__ = 0;
            size_t p_PHI_limit_0__ = 3;
            for (size_t i_0__ = 0; i_0__ < p_PHI_limit_0__; ++i_0__) {
                p_PHI[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 243;
            validate_non_negative_index("p_BET", "2", 2);
            context__.validate_dims("data initialization", "p_BET", "double", context__.to_vec(2));
            validate_non_negative_index("p_BET", "2", 2);
            p_BET = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("p_BET");
            pos__ = 0;
            size_t p_BET_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < p_BET_limit_0__; ++i_0__) {
                p_BET[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 244;
            validate_non_negative_index("p_ONS", "N_cases", N_cases);
            validate_non_negative_index("p_ONS", "3", 3);
            context__.validate_dims("data initialization", "p_ONS", "double", context__.to_vec(N_cases,3));
            validate_non_negative_index("p_ONS", "N_cases", N_cases);
            validate_non_negative_index("p_ONS", "3", 3);
            p_ONS = std::vector<std::vector<double> >(N_cases,std::vector<double>(3,double(0)));
            vals_r__ = context__.vals_r("p_ONS");
            pos__ = 0;
            size_t p_ONS_limit_1__ = 3;
            for (size_t i_1__ = 0; i_1__ < p_ONS_limit_1__; ++i_1__) {
                size_t p_ONS_limit_0__ = N_cases;
                for (size_t i_0__ = 0; i_0__ < p_ONS_limit_0__; ++i_0__) {
                    p_ONS[i_0__][i_1__] = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 247;
            context__.validate_dims("data initialization", "M_max", "int", context__.to_vec());
            M_max = int(0);
            vals_i__ = context__.vals_i("M_max");
            pos__ = 0;
            M_max = vals_i__[pos__++];
            current_statement_begin__ = 248;
            validate_non_negative_index("caseID_to_rows", "N_cases", N_cases);
            validate_non_negative_index("caseID_to_rows", "M_max", M_max);
            context__.validate_dims("data initialization", "caseID_to_rows", "int", context__.to_vec(N_cases,M_max));
            validate_non_negative_index("caseID_to_rows", "N_cases", N_cases);
            validate_non_negative_index("caseID_to_rows", "M_max", M_max);
            caseID_to_rows = std::vector<std::vector<int> >(N_cases,std::vector<int>(M_max,int(0)));
            vals_i__ = context__.vals_i("caseID_to_rows");
            pos__ = 0;
            size_t caseID_to_rows_limit_1__ = M_max;
            for (size_t i_1__ = 0; i_1__ < caseID_to_rows_limit_1__; ++i_1__) {
                size_t caseID_to_rows_limit_0__ = N_cases;
                for (size_t i_0__ = 0; i_0__ < caseID_to_rows_limit_0__; ++i_0__) {
                    caseID_to_rows[i_0__][i_1__] = vals_i__[pos__++];
                }
            }
            current_statement_begin__ = 249;
            validate_non_negative_index("row_to_caseID", "(n + n_test)", (n + n_test));
            context__.validate_dims("data initialization", "row_to_caseID", "int", context__.to_vec((n + n_test)));
            validate_non_negative_index("row_to_caseID", "(n + n_test)", (n + n_test));
            row_to_caseID = std::vector<int>((n + n_test),int(0));
            vals_i__ = context__.vals_i("row_to_caseID");
            pos__ = 0;
            size_t row_to_caseID_limit_0__ = (n + n_test);
            for (size_t i_0__ = 0; i_0__ < row_to_caseID_limit_0__; ++i_0__) {
                row_to_caseID[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 250;
            validate_non_negative_index("caseID_nrows", "N_cases", N_cases);
            context__.validate_dims("data initialization", "caseID_nrows", "int", context__.to_vec(N_cases));
            validate_non_negative_index("caseID_nrows", "N_cases", N_cases);
            caseID_nrows = std::vector<int>(N_cases,int(0));
            vals_i__ = context__.vals_i("caseID_nrows");
            pos__ = 0;
            size_t caseID_nrows_limit_0__ = N_cases;
            for (size_t i_0__ = 0; i_0__ < caseID_nrows_limit_0__; ++i_0__) {
                caseID_nrows[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 253;
            validate_non_negative_index("T_observed", "N_cases", N_cases);
            context__.validate_dims("data initialization", "T_observed", "vector_d", context__.to_vec(N_cases));
            validate_non_negative_index("T_observed", "N_cases", N_cases);
            T_observed = vector_d(static_cast<Eigen::VectorXd::Index>(N_cases));
            vals_r__ = context__.vals_r("T_observed");
            pos__ = 0;
            size_t T_observed_i_vec_lim__ = N_cases;
            for (size_t i_vec__ = 0; i_vec__ < T_observed_i_vec_lim__; ++i_vec__) {
                T_observed[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 254;
            validate_non_negative_index("L_ons", "UNCRT", UNCRT);
            validate_non_negative_index("L_ons", "N_cases", N_cases);
            context__.validate_dims("data initialization", "L_ons", "vector_d", context__.to_vec(UNCRT,N_cases));
            validate_non_negative_index("L_ons", "UNCRT", UNCRT);
            validate_non_negative_index("L_ons", "N_cases", N_cases);
            L_ons = std::vector<vector_d>(UNCRT,vector_d(static_cast<Eigen::VectorXd::Index>(N_cases)));
            vals_r__ = context__.vals_r("L_ons");
            pos__ = 0;
            size_t L_ons_i_vec_lim__ = N_cases;
            for (size_t i_vec__ = 0; i_vec__ < L_ons_i_vec_lim__; ++i_vec__) {
                size_t L_ons_limit_0__ = UNCRT;
                for (size_t i_0__ = 0; i_0__ < L_ons_limit_0__; ++i_0__) {
                    L_ons[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 255;
            validate_non_negative_index("U_ons", "UNCRT", UNCRT);
            validate_non_negative_index("U_ons", "N_cases", N_cases);
            context__.validate_dims("data initialization", "U_ons", "vector_d", context__.to_vec(UNCRT,N_cases));
            validate_non_negative_index("U_ons", "UNCRT", UNCRT);
            validate_non_negative_index("U_ons", "N_cases", N_cases);
            U_ons = std::vector<vector_d>(UNCRT,vector_d(static_cast<Eigen::VectorXd::Index>(N_cases)));
            vals_r__ = context__.vals_r("U_ons");
            pos__ = 0;
            size_t U_ons_i_vec_lim__ = N_cases;
            for (size_t i_vec__ = 0; i_vec__ < U_ons_i_vec_lim__; ++i_vec__) {
                size_t U_ons_limit_0__ = UNCRT;
                for (size_t i_0__ = 0; i_0__ < U_ons_limit_0__; ++i_0__) {
                    U_ons[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 256;
            context__.validate_dims("data initialization", "backwards", "int", context__.to_vec());
            backwards = int(0);
            vals_i__ = context__.vals_i("backwards");
            pos__ = 0;
            backwards = vals_i__[pos__++];
            current_statement_begin__ = 259;
            context__.validate_dims("data initialization", "DELTA", "double", context__.to_vec());
            DELTA = double(0);
            vals_r__ = context__.vals_r("DELTA");
            pos__ = 0;
            DELTA = vals_r__[pos__++];
            current_statement_begin__ = 260;
            context__.validate_dims("data initialization", "C_hat", "double", context__.to_vec());
            C_hat = double(0);
            vals_r__ = context__.vals_r("C_hat");
            pos__ = 0;
            C_hat = vals_r__[pos__++];
            current_statement_begin__ = 261;
            validate_non_negative_index("HS", "6", 6);
            context__.validate_dims("data initialization", "HS", "int", context__.to_vec(6));
            validate_non_negative_index("HS", "6", 6);
            HS = std::vector<int>(6,int(0));
            vals_i__ = context__.vals_i("HS");
            pos__ = 0;
            size_t HS_limit_0__ = 6;
            for (size_t i_0__ = 0; i_0__ < HS_limit_0__; ++i_0__) {
                HS[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 262;
            context__.validate_dims("data initialization", "F_is_sampled", "int", context__.to_vec());
            F_is_sampled = int(0);
            vals_i__ = context__.vals_i("F_is_sampled");
            pos__ = 0;
            F_is_sampled = vals_i__[pos__++];
            current_statement_begin__ = 266;
            context__.validate_dims("data initialization", "USE_VAR_MASK", "int", context__.to_vec());
            USE_VAR_MASK = int(0);
            vals_i__ = context__.vals_i("USE_VAR_MASK");
            pos__ = 0;
            USE_VAR_MASK = vals_i__[pos__++];
            current_statement_begin__ = 267;
            validate_non_negative_index("vm_params", "2", 2);
            context__.validate_dims("data initialization", "vm_params", "double", context__.to_vec(2));
            validate_non_negative_index("vm_params", "2", 2);
            vm_params = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("vm_params");
            pos__ = 0;
            size_t vm_params_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < vm_params_limit_0__; ++i_0__) {
                vm_params[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 268;
            context__.validate_dims("data initialization", "cat_interact_kernel", "int", context__.to_vec());
            cat_interact_kernel = int(0);
            vals_i__ = context__.vals_i("cat_interact_kernel");
            pos__ = 0;
            cat_interact_kernel = vals_i__[pos__++];

            // validate, data variables
            current_statement_begin__ = 193;
            check_greater_or_equal(function__,"N_tot",N_tot,1);
            current_statement_begin__ = 194;
            check_greater_or_equal(function__,"N_cases",N_cases,0);
            current_statement_begin__ = 195;
            check_greater_or_equal(function__,"d",d,2);
            current_statement_begin__ = 196;
            check_greater_or_equal(function__,"n",n,1);
            current_statement_begin__ = 197;
            check_greater_or_equal(function__,"n_test",n_test,0);
            current_statement_begin__ = 201;
            current_statement_begin__ = 202;
            current_statement_begin__ = 203;
            current_statement_begin__ = 204;
            current_statement_begin__ = 205;
            current_statement_begin__ = 208;
            check_greater_or_equal(function__,"LH",LH,0);
            check_less_or_equal(function__,"LH",LH,3);
            current_statement_begin__ = 217;
            for (int k0__ = 0; k0__ < 6; ++k0__) {
                check_greater_or_equal(function__,"D[k0__]",D[k0__],0);
            }
            current_statement_begin__ = 220;
            check_greater_or_equal(function__,"UNCRT",UNCRT,0);
            check_less_or_equal(function__,"UNCRT",UNCRT,1);
            current_statement_begin__ = 221;
            check_greater_or_equal(function__,"HMGNS",HMGNS,0);
            check_less_or_equal(function__,"HMGNS",HMGNS,1);
            current_statement_begin__ = 224;
            current_statement_begin__ = 225;
            current_statement_begin__ = 226;
            current_statement_begin__ = 227;
            current_statement_begin__ = 228;
            current_statement_begin__ = 229;
            current_statement_begin__ = 230;
            current_statement_begin__ = 231;
            current_statement_begin__ = 232;
            current_statement_begin__ = 235;
            current_statement_begin__ = 236;
            current_statement_begin__ = 237;
            current_statement_begin__ = 238;
            current_statement_begin__ = 239;
            current_statement_begin__ = 240;
            current_statement_begin__ = 241;
            current_statement_begin__ = 242;
            current_statement_begin__ = 243;
            current_statement_begin__ = 244;
            current_statement_begin__ = 247;
            check_greater_or_equal(function__,"M_max",M_max,0);
            check_less_or_equal(function__,"M_max",M_max,(n + n_test));
            current_statement_begin__ = 248;
            for (int k0__ = 0; k0__ < N_cases; ++k0__) {
                for (int k1__ = 0; k1__ < M_max; ++k1__) {
                    check_greater_or_equal(function__,"caseID_to_rows[k0__][k1__]",caseID_to_rows[k0__][k1__],0);
                }
            }
            current_statement_begin__ = 249;
            for (int k0__ = 0; k0__ < (n + n_test); ++k0__) {
                check_greater_or_equal(function__,"row_to_caseID[k0__]",row_to_caseID[k0__],0);
                check_less_or_equal(function__,"row_to_caseID[k0__]",row_to_caseID[k0__],N_cases);
            }
            current_statement_begin__ = 250;
            for (int k0__ = 0; k0__ < N_cases; ++k0__) {
                check_greater_or_equal(function__,"caseID_nrows[k0__]",caseID_nrows[k0__],0);
                check_less_or_equal(function__,"caseID_nrows[k0__]",caseID_nrows[k0__],M_max);
            }
            current_statement_begin__ = 253;
            current_statement_begin__ = 254;
            current_statement_begin__ = 255;
            current_statement_begin__ = 256;
            check_greater_or_equal(function__,"backwards",backwards,0);
            check_less_or_equal(function__,"backwards",backwards,1);
            current_statement_begin__ = 259;
            current_statement_begin__ = 260;
            current_statement_begin__ = 261;
            current_statement_begin__ = 262;
            current_statement_begin__ = 266;
            check_greater_or_equal(function__,"USE_VAR_MASK",USE_VAR_MASK,0);
            check_less_or_equal(function__,"USE_VAR_MASK",USE_VAR_MASK,1);
            current_statement_begin__ = 267;
            current_statement_begin__ = 268;
            check_greater_or_equal(function__,"cat_interact_kernel",cat_interact_kernel,0);
            check_less_or_equal(function__,"cat_interact_kernel",cat_interact_kernel,1);
            // initialize data variables
            current_statement_begin__ = 273;
            n_tot = int(0);
            stan::math::fill(n_tot, std::numeric_limits<int>::min());
            stan::math::assign(n_tot,(n + n_test));
            current_statement_begin__ = 274;
            nf = int(0);
            stan::math::fill(nf, std::numeric_limits<int>::min());
            stan::math::assign(nf,(((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + get_base1(D,6,"D",1)));
            current_statement_begin__ = 275;
            sum_D = int(0);
            stan::math::fill(sum_D, std::numeric_limits<int>::min());
            stan::math::assign(sum_D,sum(D));
            current_statement_begin__ = 276;
            validate_non_negative_index("KF", "nf", nf);
            validate_non_negative_index("KF", "n_tot", n_tot);
            validate_non_negative_index("KF", "n_tot", n_tot);
            KF = std::vector<matrix_d>(nf,matrix_d(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot)));
            stan::math::fill(KF,DUMMY_VAR__);
            current_statement_begin__ = 277;
            validate_non_negative_index("x_age", "n_tot", n_tot);
            x_age = std::vector<double>(n_tot,double(0));
            stan::math::fill(x_age,DUMMY_VAR__);
            stan::math::assign(x_age,to_array_1d(get_base1(X,2,"X",1)));
            current_statement_begin__ = 280;
            validate_non_negative_index("mu", "n_tot", n_tot);
            mu = vector_d(static_cast<Eigen::VectorXd::Index>(n_tot));
            stan::math::fill(mu,DUMMY_VAR__);
            stan::math::assign(mu,rep_vector(C_hat,n_tot));

            current_statement_begin__ = 283;
            stan::model::assign(KF, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                        K_cat(get_base1(X,1,"X",1),get_base1(X,1,"X",1), pstream__), 
                        "assigning variable KF");
            current_statement_begin__ = 284;
            for (int j = 1; j <= get_base1(D,3,"D",1); ++j) {

                current_statement_begin__ = 285;
                stan::model::assign(KF, 
                            stan::model::cons_list(stan::model::index_uni((1 + j)), stan::model::nil_index_list()), 
                            K_bin_int(X_notnan,X_notnan,1, pstream__), 
                            "assigning variable KF");
            }
            current_statement_begin__ = 287;
            for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {
                {
                current_statement_begin__ = 288;
                int ix(0);
                (void) ix;  // dummy to suppress unused var warning

                stan::math::fill(ix, std::numeric_limits<int>::min());
                stan::math::assign(ix,(((2 + get_base1(D,3,"D",1)) + get_base1(D,4,"D",1)) + j));


                current_statement_begin__ = 289;
                if (as_bool(logical_eq(cat_interact_kernel,1))) {

                    current_statement_begin__ = 290;
                    stan::model::assign(KF, 
                                stan::model::cons_list(stan::model::index_uni(((1 + get_base1(D,3,"D",1)) + j)), stan::model::nil_index_list()), 
                                K_cat(get_base1(X,ix,"X",1),get_base1(X,ix,"X",1), pstream__), 
                                "assigning variable KF");
                } else {

                    current_statement_begin__ = 292;
                    stan::model::assign(KF, 
                                stan::model::cons_list(stan::model::index_uni(((1 + get_base1(D,3,"D",1)) + j)), stan::model::nil_index_list()), 
                                K_bin_real(get_base1(X,ix,"X",1),get_base1(X,ix,"X",1),1, pstream__), 
                                "assigning variable KF");
                }
                }
            }
            current_statement_begin__ = 295;
            for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {
                {
                current_statement_begin__ = 296;
                int ix(0);
                (void) ix;  // dummy to suppress unused var warning

                stan::math::fill(ix, std::numeric_limits<int>::min());
                stan::math::assign(ix,((((2 + get_base1(D,3,"D",1)) + get_base1(D,4,"D",1)) + get_base1(D,5,"D",1)) + j));


                current_statement_begin__ = 297;
                stan::model::assign(KF, 
                            stan::model::cons_list(stan::model::index_uni((((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + j)), stan::model::nil_index_list()), 
                            K_cat(get_base1(X,ix,"X",1),get_base1(X,ix,"X",1), pstream__), 
                            "assigning variable KF");
                }
            }
            current_statement_begin__ = 301;
            if (pstream__) {
                stan_print(pstream__," ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 302;
            if (pstream__) {
                stan_print(pstream__,"* Likelihood = ");
                stan_print(pstream__,LH);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 303;
            if (pstream__) {
                stan_print(pstream__,"* Number of data points = ");
                stan_print(pstream__,n);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 304;
            if (pstream__) {
                stan_print(pstream__,"* Number of test points = ");
                stan_print(pstream__,n_test);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 305;
            if (pstream__) {
                stan_print(pstream__,"* Number of model components = ");
                stan_print(pstream__,sum_D);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 306;
            if (pstream__) {
                stan_print(pstream__,"* Number of individuals = ");
                stan_print(pstream__,N_tot);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 307;
            if (pstream__) {
                stan_print(pstream__,"* Additional model info:");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 308;
            if (as_bool(logical_neq(LH,1))) {

                current_statement_begin__ = 309;
                if (pstream__) {
                    stan_print(pstream__,"  - C_hat = ");
                    stan_print(pstream__,C_hat);
                    *pstream__ << std::endl;
                }
            }
            current_statement_begin__ = 311;
            if (pstream__) {
                stan_print(pstream__,"  - D = ");
                stan_print(pstream__,D);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 312;
            if (pstream__) {
                stan_print(pstream__,"  - F_is_sampled = ");
                stan_print(pstream__,F_is_sampled);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 313;
            if (pstream__) {
                stan_print(pstream__,"  - cat_interact_kernel = ");
                stan_print(pstream__,cat_interact_kernel);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 314;
            if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {

                current_statement_begin__ = 315;
                if (pstream__) {
                    stan_print(pstream__,"* Disease modeling info: ");
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 316;
                if (pstream__) {
                    stan_print(pstream__,"  - Number of cases = ");
                    stan_print(pstream__,N_cases);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 317;
                if (pstream__) {
                    stan_print(pstream__,"  - UNCRT = ");
                    stan_print(pstream__,UNCRT);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 318;
                if (pstream__) {
                    stan_print(pstream__,"  - HMGNS = ");
                    stan_print(pstream__,HMGNS);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 319;
                if (pstream__) {
                    stan_print(pstream__,"  - USE_VAR_MASK = ");
                    stan_print(pstream__,USE_VAR_MASK);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 320;
                if (as_bool(logical_eq(USE_VAR_MASK,1))) {

                    current_statement_begin__ = 321;
                    if (pstream__) {
                        stan_print(pstream__,"      o vm_params = ");
                        stan_print(pstream__,vm_params);
                        *pstream__ << std::endl;
                    }
                }
            }
            current_statement_begin__ = 324;
            if (pstream__) {
                stan_print(pstream__," ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 327;
            if (as_bool((primitive_value(logical_neq(n_test,0)) && primitive_value((1 - F_is_sampled))))) {

                current_statement_begin__ = 328;
                std::stringstream errmsg_stream__;
                errmsg_stream__ << "Number of test points must be zero if F is not sampled!";
                throw std::domain_error(errmsg_stream__.str());
            }

            // validate transformed data
            current_statement_begin__ = 273;
            current_statement_begin__ = 274;
            current_statement_begin__ = 275;
            current_statement_begin__ = 276;
            current_statement_begin__ = 277;
            current_statement_begin__ = 280;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 335;
            validate_non_negative_index("alpha_idAge", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            num_params_r__ += get_base1(D,1,"D",1);
            current_statement_begin__ = 336;
            validate_non_negative_index("alpha_sharedAge", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            num_params_r__ += get_base1(D,2,"D",1);
            current_statement_begin__ = 337;
            validate_non_negative_index("alpha_diseaseAge", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            num_params_r__ += get_base1(D,3,"D",1);
            current_statement_begin__ = 338;
            validate_non_negative_index("alpha_continuous", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            num_params_r__ += get_base1(D,4,"D",1);
            current_statement_begin__ = 339;
            validate_non_negative_index("alpha_categAge", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            num_params_r__ += get_base1(D,5,"D",1);
            current_statement_begin__ = 340;
            validate_non_negative_index("alpha_categOffset", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
            num_params_r__ += get_base1(D,6,"D",1);
            current_statement_begin__ = 343;
            validate_non_negative_index("lengthscale_idAge", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
            num_params_r__ += get_base1(D,1,"D",1);
            current_statement_begin__ = 344;
            validate_non_negative_index("lengthscale_sharedAge", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
            num_params_r__ += get_base1(D,2,"D",1);
            current_statement_begin__ = 345;
            validate_non_negative_index("lengthscale_diseaseAge", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            num_params_r__ += get_base1(D,3,"D",1);
            current_statement_begin__ = 346;
            validate_non_negative_index("lengthscale_continuous", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
            num_params_r__ += get_base1(D,4,"D",1);
            current_statement_begin__ = 347;
            validate_non_negative_index("lengthscale_categAge", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
            num_params_r__ += get_base1(D,5,"D",1);
            current_statement_begin__ = 350;
            validate_non_negative_index("warp_steepness", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
            num_params_r__ += get_base1(D,3,"D",1);
            current_statement_begin__ = 351;
            validate_non_negative_index("sigma_n", "(primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)))", (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))));
            num_params_r__ += (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)));
            current_statement_begin__ = 352;
            validate_non_negative_index("ETA", "n_tot", n_tot);
            validate_non_negative_index("ETA", "F_is_sampled", F_is_sampled);
            validate_non_negative_index("ETA", "sum_D", sum_D);
            num_params_r__ += n_tot * F_is_sampled * sum_D;
            current_statement_begin__ = 353;
            validate_non_negative_index("phi", "(primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)))", (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))));
            num_params_r__ += (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)));
            current_statement_begin__ = 356;
            validate_non_negative_index("beta", "N_cases", N_cases);
            validate_non_negative_index("beta", "logical_eq(HMGNS,0)", logical_eq(HMGNS,0));
            num_params_r__ += N_cases * logical_eq(HMGNS,0);
            current_statement_begin__ = 357;
            validate_non_negative_index("T_raw", "N_cases", N_cases);
            validate_non_negative_index("T_raw", "logical_eq(UNCRT,1)", logical_eq(UNCRT,1));
            num_params_r__ += N_cases * logical_eq(UNCRT,1);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_lgp() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("alpha_idAge")))
            throw std::runtime_error("variable alpha_idAge missing");
        vals_r__ = context__.vals_r("alpha_idAge");
        pos__ = 0U;
        validate_non_negative_index("alpha_idAge", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
        context__.validate_dims("initialization", "alpha_idAge", "double", context__.to_vec(get_base1(D,1,"D",1)));
        std::vector<double> alpha_idAge(get_base1(D,1,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,1,"D",1); ++i0__)
            alpha_idAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,1,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_idAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_idAge: ") + e.what());
        }

        if (!(context__.contains_r("alpha_sharedAge")))
            throw std::runtime_error("variable alpha_sharedAge missing");
        vals_r__ = context__.vals_r("alpha_sharedAge");
        pos__ = 0U;
        validate_non_negative_index("alpha_sharedAge", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
        context__.validate_dims("initialization", "alpha_sharedAge", "double", context__.to_vec(get_base1(D,2,"D",1)));
        std::vector<double> alpha_sharedAge(get_base1(D,2,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,2,"D",1); ++i0__)
            alpha_sharedAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,2,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_sharedAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_sharedAge: ") + e.what());
        }

        if (!(context__.contains_r("alpha_diseaseAge")))
            throw std::runtime_error("variable alpha_diseaseAge missing");
        vals_r__ = context__.vals_r("alpha_diseaseAge");
        pos__ = 0U;
        validate_non_negative_index("alpha_diseaseAge", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
        context__.validate_dims("initialization", "alpha_diseaseAge", "double", context__.to_vec(get_base1(D,3,"D",1)));
        std::vector<double> alpha_diseaseAge(get_base1(D,3,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            alpha_diseaseAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_diseaseAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_diseaseAge: ") + e.what());
        }

        if (!(context__.contains_r("alpha_continuous")))
            throw std::runtime_error("variable alpha_continuous missing");
        vals_r__ = context__.vals_r("alpha_continuous");
        pos__ = 0U;
        validate_non_negative_index("alpha_continuous", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
        context__.validate_dims("initialization", "alpha_continuous", "double", context__.to_vec(get_base1(D,4,"D",1)));
        std::vector<double> alpha_continuous(get_base1(D,4,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,4,"D",1); ++i0__)
            alpha_continuous[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,4,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_continuous[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_continuous: ") + e.what());
        }

        if (!(context__.contains_r("alpha_categAge")))
            throw std::runtime_error("variable alpha_categAge missing");
        vals_r__ = context__.vals_r("alpha_categAge");
        pos__ = 0U;
        validate_non_negative_index("alpha_categAge", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
        context__.validate_dims("initialization", "alpha_categAge", "double", context__.to_vec(get_base1(D,5,"D",1)));
        std::vector<double> alpha_categAge(get_base1(D,5,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,5,"D",1); ++i0__)
            alpha_categAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,5,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_categAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_categAge: ") + e.what());
        }

        if (!(context__.contains_r("alpha_categOffset")))
            throw std::runtime_error("variable alpha_categOffset missing");
        vals_r__ = context__.vals_r("alpha_categOffset");
        pos__ = 0U;
        validate_non_negative_index("alpha_categOffset", "get_base1(D,6,\"D\",1)", get_base1(D,6,"D",1));
        context__.validate_dims("initialization", "alpha_categOffset", "double", context__.to_vec(get_base1(D,6,"D",1)));
        std::vector<double> alpha_categOffset(get_base1(D,6,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,6,"D",1); ++i0__)
            alpha_categOffset[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,6,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,alpha_categOffset[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable alpha_categOffset: ") + e.what());
        }

        if (!(context__.contains_r("lengthscale_idAge")))
            throw std::runtime_error("variable lengthscale_idAge missing");
        vals_r__ = context__.vals_r("lengthscale_idAge");
        pos__ = 0U;
        validate_non_negative_index("lengthscale_idAge", "get_base1(D,1,\"D\",1)", get_base1(D,1,"D",1));
        context__.validate_dims("initialization", "lengthscale_idAge", "double", context__.to_vec(get_base1(D,1,"D",1)));
        std::vector<double> lengthscale_idAge(get_base1(D,1,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,1,"D",1); ++i0__)
            lengthscale_idAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,1,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,lengthscale_idAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lengthscale_idAge: ") + e.what());
        }

        if (!(context__.contains_r("lengthscale_sharedAge")))
            throw std::runtime_error("variable lengthscale_sharedAge missing");
        vals_r__ = context__.vals_r("lengthscale_sharedAge");
        pos__ = 0U;
        validate_non_negative_index("lengthscale_sharedAge", "get_base1(D,2,\"D\",1)", get_base1(D,2,"D",1));
        context__.validate_dims("initialization", "lengthscale_sharedAge", "double", context__.to_vec(get_base1(D,2,"D",1)));
        std::vector<double> lengthscale_sharedAge(get_base1(D,2,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,2,"D",1); ++i0__)
            lengthscale_sharedAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,2,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,lengthscale_sharedAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lengthscale_sharedAge: ") + e.what());
        }

        if (!(context__.contains_r("lengthscale_diseaseAge")))
            throw std::runtime_error("variable lengthscale_diseaseAge missing");
        vals_r__ = context__.vals_r("lengthscale_diseaseAge");
        pos__ = 0U;
        validate_non_negative_index("lengthscale_diseaseAge", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
        context__.validate_dims("initialization", "lengthscale_diseaseAge", "double", context__.to_vec(get_base1(D,3,"D",1)));
        std::vector<double> lengthscale_diseaseAge(get_base1(D,3,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            lengthscale_diseaseAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,lengthscale_diseaseAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lengthscale_diseaseAge: ") + e.what());
        }

        if (!(context__.contains_r("lengthscale_continuous")))
            throw std::runtime_error("variable lengthscale_continuous missing");
        vals_r__ = context__.vals_r("lengthscale_continuous");
        pos__ = 0U;
        validate_non_negative_index("lengthscale_continuous", "get_base1(D,4,\"D\",1)", get_base1(D,4,"D",1));
        context__.validate_dims("initialization", "lengthscale_continuous", "double", context__.to_vec(get_base1(D,4,"D",1)));
        std::vector<double> lengthscale_continuous(get_base1(D,4,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,4,"D",1); ++i0__)
            lengthscale_continuous[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,4,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,lengthscale_continuous[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lengthscale_continuous: ") + e.what());
        }

        if (!(context__.contains_r("lengthscale_categAge")))
            throw std::runtime_error("variable lengthscale_categAge missing");
        vals_r__ = context__.vals_r("lengthscale_categAge");
        pos__ = 0U;
        validate_non_negative_index("lengthscale_categAge", "get_base1(D,5,\"D\",1)", get_base1(D,5,"D",1));
        context__.validate_dims("initialization", "lengthscale_categAge", "double", context__.to_vec(get_base1(D,5,"D",1)));
        std::vector<double> lengthscale_categAge(get_base1(D,5,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,5,"D",1); ++i0__)
            lengthscale_categAge[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,5,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,lengthscale_categAge[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable lengthscale_categAge: ") + e.what());
        }

        if (!(context__.contains_r("warp_steepness")))
            throw std::runtime_error("variable warp_steepness missing");
        vals_r__ = context__.vals_r("warp_steepness");
        pos__ = 0U;
        validate_non_negative_index("warp_steepness", "get_base1(D,3,\"D\",1)", get_base1(D,3,"D",1));
        context__.validate_dims("initialization", "warp_steepness", "double", context__.to_vec(get_base1(D,3,"D",1)));
        std::vector<double> warp_steepness(get_base1(D,3,"D",1),double(0));
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            warp_steepness[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < get_base1(D,3,"D",1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,warp_steepness[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable warp_steepness: ") + e.what());
        }

        if (!(context__.contains_r("sigma_n")))
            throw std::runtime_error("variable sigma_n missing");
        vals_r__ = context__.vals_r("sigma_n");
        pos__ = 0U;
        validate_non_negative_index("sigma_n", "(primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)))", (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))));
        context__.validate_dims("initialization", "sigma_n", "double", context__.to_vec((primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)))));
        std::vector<double> sigma_n((primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))),double(0));
        for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))); ++i0__)
            sigma_n[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,sigma_n[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sigma_n: ") + e.what());
        }

        if (!(context__.contains_r("ETA")))
            throw std::runtime_error("variable ETA missing");
        vals_r__ = context__.vals_r("ETA");
        pos__ = 0U;
        validate_non_negative_index("ETA", "F_is_sampled", F_is_sampled);
        validate_non_negative_index("ETA", "sum_D", sum_D);
        validate_non_negative_index("ETA", "n_tot", n_tot);
        context__.validate_dims("initialization", "ETA", "vector_d", context__.to_vec(F_is_sampled,sum_D,n_tot));
        std::vector<std::vector<vector_d> > ETA(F_is_sampled,std::vector<vector_d>(sum_D,vector_d(static_cast<Eigen::VectorXd::Index>(n_tot))));
        for (int j1__ = 0U; j1__ < n_tot; ++j1__)
            for (int i1__ = 0U; i1__ < sum_D; ++i1__)
                for (int i0__ = 0U; i0__ < F_is_sampled; ++i0__)
                    ETA[i0__][i1__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < F_is_sampled; ++i0__)
            for (int i1__ = 0U; i1__ < sum_D; ++i1__)
                try {
            writer__.vector_unconstrain(ETA[i0__][i1__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ETA: ") + e.what());
        }

        if (!(context__.contains_r("phi")))
            throw std::runtime_error("variable phi missing");
        vals_r__ = context__.vals_r("phi");
        pos__ = 0U;
        validate_non_negative_index("phi", "(primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)))", (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))));
        context__.validate_dims("initialization", "phi", "double", context__.to_vec((primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)))));
        std::vector<double> phi((primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))),double(0));
        for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))); ++i0__)
            phi[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,phi[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable phi: ") + e.what());
        }

        if (!(context__.contains_r("beta")))
            throw std::runtime_error("variable beta missing");
        vals_r__ = context__.vals_r("beta");
        pos__ = 0U;
        validate_non_negative_index("beta", "logical_eq(HMGNS,0)", logical_eq(HMGNS,0));
        validate_non_negative_index("beta", "N_cases", N_cases);
        context__.validate_dims("initialization", "beta", "vector_d", context__.to_vec(logical_eq(HMGNS,0),N_cases));
        std::vector<vector_d> beta(logical_eq(HMGNS,0),vector_d(static_cast<Eigen::VectorXd::Index>(N_cases)));
        for (int j1__ = 0U; j1__ < N_cases; ++j1__)
            for (int i0__ = 0U; i0__ < logical_eq(HMGNS,0); ++i0__)
                beta[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(HMGNS,0); ++i0__)
            try {
            writer__.vector_lub_unconstrain(0,1,beta[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable beta: ") + e.what());
        }

        if (!(context__.contains_r("T_raw")))
            throw std::runtime_error("variable T_raw missing");
        vals_r__ = context__.vals_r("T_raw");
        pos__ = 0U;
        validate_non_negative_index("T_raw", "logical_eq(UNCRT,1)", logical_eq(UNCRT,1));
        validate_non_negative_index("T_raw", "N_cases", N_cases);
        context__.validate_dims("initialization", "T_raw", "vector_d", context__.to_vec(logical_eq(UNCRT,1),N_cases));
        std::vector<vector_d> T_raw(logical_eq(UNCRT,1),vector_d(static_cast<Eigen::VectorXd::Index>(N_cases)));
        for (int j1__ = 0U; j1__ < N_cases; ++j1__)
            for (int i0__ = 0U; i0__ < logical_eq(UNCRT,1); ++i0__)
                T_raw[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(UNCRT,1); ++i0__)
            try {
            writer__.vector_lub_unconstrain(0,1,T_raw[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable T_raw: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        typedef T__ local_scalar_t__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);

            vector<local_scalar_t__> alpha_idAge;
            size_t dim_alpha_idAge_0__ = get_base1(D,1,"D",1);
            alpha_idAge.reserve(dim_alpha_idAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_idAge_0__; ++k_0__) {
                if (jacobian__)
                    alpha_idAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_idAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> alpha_sharedAge;
            size_t dim_alpha_sharedAge_0__ = get_base1(D,2,"D",1);
            alpha_sharedAge.reserve(dim_alpha_sharedAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_sharedAge_0__; ++k_0__) {
                if (jacobian__)
                    alpha_sharedAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_sharedAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> alpha_diseaseAge;
            size_t dim_alpha_diseaseAge_0__ = get_base1(D,3,"D",1);
            alpha_diseaseAge.reserve(dim_alpha_diseaseAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_diseaseAge_0__; ++k_0__) {
                if (jacobian__)
                    alpha_diseaseAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_diseaseAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> alpha_continuous;
            size_t dim_alpha_continuous_0__ = get_base1(D,4,"D",1);
            alpha_continuous.reserve(dim_alpha_continuous_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_continuous_0__; ++k_0__) {
                if (jacobian__)
                    alpha_continuous.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_continuous.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> alpha_categAge;
            size_t dim_alpha_categAge_0__ = get_base1(D,5,"D",1);
            alpha_categAge.reserve(dim_alpha_categAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_categAge_0__; ++k_0__) {
                if (jacobian__)
                    alpha_categAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_categAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> alpha_categOffset;
            size_t dim_alpha_categOffset_0__ = get_base1(D,6,"D",1);
            alpha_categOffset.reserve(dim_alpha_categOffset_0__);
            for (size_t k_0__ = 0; k_0__ < dim_alpha_categOffset_0__; ++k_0__) {
                if (jacobian__)
                    alpha_categOffset.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    alpha_categOffset.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> lengthscale_idAge;
            size_t dim_lengthscale_idAge_0__ = get_base1(D,1,"D",1);
            lengthscale_idAge.reserve(dim_lengthscale_idAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lengthscale_idAge_0__; ++k_0__) {
                if (jacobian__)
                    lengthscale_idAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    lengthscale_idAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> lengthscale_sharedAge;
            size_t dim_lengthscale_sharedAge_0__ = get_base1(D,2,"D",1);
            lengthscale_sharedAge.reserve(dim_lengthscale_sharedAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lengthscale_sharedAge_0__; ++k_0__) {
                if (jacobian__)
                    lengthscale_sharedAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    lengthscale_sharedAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> lengthscale_diseaseAge;
            size_t dim_lengthscale_diseaseAge_0__ = get_base1(D,3,"D",1);
            lengthscale_diseaseAge.reserve(dim_lengthscale_diseaseAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lengthscale_diseaseAge_0__; ++k_0__) {
                if (jacobian__)
                    lengthscale_diseaseAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    lengthscale_diseaseAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> lengthscale_continuous;
            size_t dim_lengthscale_continuous_0__ = get_base1(D,4,"D",1);
            lengthscale_continuous.reserve(dim_lengthscale_continuous_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lengthscale_continuous_0__; ++k_0__) {
                if (jacobian__)
                    lengthscale_continuous.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    lengthscale_continuous.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> lengthscale_categAge;
            size_t dim_lengthscale_categAge_0__ = get_base1(D,5,"D",1);
            lengthscale_categAge.reserve(dim_lengthscale_categAge_0__);
            for (size_t k_0__ = 0; k_0__ < dim_lengthscale_categAge_0__; ++k_0__) {
                if (jacobian__)
                    lengthscale_categAge.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    lengthscale_categAge.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> warp_steepness;
            size_t dim_warp_steepness_0__ = get_base1(D,3,"D",1);
            warp_steepness.reserve(dim_warp_steepness_0__);
            for (size_t k_0__ = 0; k_0__ < dim_warp_steepness_0__; ++k_0__) {
                if (jacobian__)
                    warp_steepness.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    warp_steepness.push_back(in__.scalar_lb_constrain(0));
            }

            vector<local_scalar_t__> sigma_n;
            size_t dim_sigma_n_0__ = (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)));
            sigma_n.reserve(dim_sigma_n_0__);
            for (size_t k_0__ = 0; k_0__ < dim_sigma_n_0__; ++k_0__) {
                if (jacobian__)
                    sigma_n.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    sigma_n.push_back(in__.scalar_lb_constrain(0));
            }

            vector<vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > > ETA;
            size_t dim_ETA_0__ = F_is_sampled;
            ETA.resize(dim_ETA_0__);
            for (size_t k_0__ = 0; k_0__ < dim_ETA_0__; ++k_0__) {
                size_t dim_ETA_1__ = sum_D;
                ETA[k_0__].reserve(dim_ETA_1__);
                for (size_t k_1__ = 0; k_1__ < dim_ETA_1__; ++k_1__) {
                    if (jacobian__)
                        ETA[k_0__].push_back(in__.vector_constrain(n_tot,lp__));
                    else
                        ETA[k_0__].push_back(in__.vector_constrain(n_tot));
                }
            }

            vector<local_scalar_t__> phi;
            size_t dim_phi_0__ = (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)));
            phi.reserve(dim_phi_0__);
            for (size_t k_0__ = 0; k_0__ < dim_phi_0__; ++k_0__) {
                if (jacobian__)
                    phi.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    phi.push_back(in__.scalar_lb_constrain(0));
            }

            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > beta;
            size_t dim_beta_0__ = logical_eq(HMGNS,0);
            beta.reserve(dim_beta_0__);
            for (size_t k_0__ = 0; k_0__ < dim_beta_0__; ++k_0__) {
                if (jacobian__)
                    beta.push_back(in__.vector_lub_constrain(0,1,N_cases,lp__));
                else
                    beta.push_back(in__.vector_lub_constrain(0,1,N_cases));
            }

            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > T_raw;
            size_t dim_T_raw_0__ = logical_eq(UNCRT,1);
            T_raw.reserve(dim_T_raw_0__);
            for (size_t k_0__ = 0; k_0__ < dim_T_raw_0__; ++k_0__) {
                if (jacobian__)
                    T_raw.push_back(in__.vector_lub_constrain(0,1,N_cases,lp__));
                else
                    T_raw.push_back(in__.vector_lub_constrain(0,1,N_cases));
            }


            // transformed parameters
            current_statement_begin__ = 362;
            validate_non_negative_index("T_onset", "N_cases", N_cases);
            validate_non_negative_index("T_onset", "UNCRT", UNCRT);
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > T_onset(UNCRT, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(N_cases))));
            stan::math::initialize(T_onset, DUMMY_VAR__);
            stan::math::fill(T_onset,DUMMY_VAR__);
            current_statement_begin__ = 363;
            validate_non_negative_index("F", "n_tot", n_tot);
            validate_non_negative_index("F", "F_is_sampled", F_is_sampled);
            validate_non_negative_index("F", "sum_D", sum_D);
            vector<vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > > F(F_is_sampled, (vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> >(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n_tot))))));
            stan::math::initialize(F, DUMMY_VAR__);
            stan::math::fill(F,DUMMY_VAR__);


            current_statement_begin__ = 364;
            if (as_bool(UNCRT)) {

                current_statement_begin__ = 365;
                stan::model::assign(T_onset, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            add(get_base1(L_ons,1,"L_ons",1),elt_multiply(subtract(get_base1(U_ons,1,"U_ons",1),get_base1(L_ons,1,"L_ons",1)),get_base1(T_raw,1,"T_raw",1))), 
                            "assigning variable T_onset");
            }
            current_statement_begin__ = 367;
            if (as_bool(F_is_sampled)) {
                {
                current_statement_begin__ = 370;
                validate_non_negative_index("Kxr", "n_tot", n_tot);
                validate_non_negative_index("Kxr", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Kxr(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) Kxr;  // dummy to suppress unused var warning

                stan::math::initialize(Kxr, DUMMY_VAR__);
                stan::math::fill(Kxr,DUMMY_VAR__);
                current_statement_begin__ = 371;
                validate_non_negative_index("Lxr", "n_tot", n_tot);
                validate_non_negative_index("Lxr", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Lxr(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) Lxr;  // dummy to suppress unused var warning

                stan::math::initialize(Lxr, DUMMY_VAR__);
                stan::math::fill(Lxr,DUMMY_VAR__);
                current_statement_begin__ = 372;
                validate_non_negative_index("EYE", "n_tot", n_tot);
                validate_non_negative_index("EYE", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  EYE(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) EYE;  // dummy to suppress unused var warning

                stan::math::initialize(EYE, DUMMY_VAR__);
                stan::math::fill(EYE,DUMMY_VAR__);
                stan::math::assign(EYE,diag_matrix(rep_vector(DELTA,n_tot)));
                current_statement_begin__ = 373;
                int r(0);
                (void) r;  // dummy to suppress unused var warning

                stan::math::fill(r, std::numeric_limits<int>::min());
                stan::math::assign(r,0);


                current_statement_begin__ = 374;
                if (as_bool(logical_eq(get_base1(D,1,"D",1),1))) {

                    current_statement_begin__ = 375;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 376;
                    stan::math::assign(Kxr, elt_multiply(cov_exp_quad(x_age,get_base1(alpha_idAge,1,"alpha_idAge",1),get_base1(lengthscale_idAge,1,"lengthscale_idAge",1)),get_base1(KF,1,"KF",1)));
                    current_statement_begin__ = 377;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 378;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 380;
                if (as_bool(logical_eq(get_base1(D,2,"D",1),1))) {

                    current_statement_begin__ = 381;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 382;
                    stan::math::assign(Kxr, cov_exp_quad(x_age,get_base1(alpha_sharedAge,1,"alpha_sharedAge",1),get_base1(lengthscale_sharedAge,1,"lengthscale_sharedAge",1)));
                    current_statement_begin__ = 383;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 384;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 386;
                if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {
                    {
                    current_statement_begin__ = 387;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_diseaseAge,1,"alpha_diseaseAge",1));
                    current_statement_begin__ = 388;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_diseaseAge,1,"lengthscale_diseaseAge",1));
                    current_statement_begin__ = 389;
                    local_scalar_t__ stp;
                    (void) stp;  // dummy to suppress unused var warning

                    stan::math::initialize(stp, DUMMY_VAR__);
                    stan::math::fill(stp,DUMMY_VAR__);
                    stan::math::assign(stp,get_base1(warp_steepness,1,"warp_steepness",1));
                    current_statement_begin__ = 390;
                    validate_non_negative_index("x_tilde", "n_tot", n_tot);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  x_tilde(static_cast<Eigen::VectorXd::Index>(n_tot));
                    (void) x_tilde;  // dummy to suppress unused var warning

                    stan::math::initialize(x_tilde, DUMMY_VAR__);
                    stan::math::fill(x_tilde,DUMMY_VAR__);
                    current_statement_begin__ = 391;
                    validate_non_negative_index("w", "n_tot", n_tot);
                    vector<local_scalar_t__> w(n_tot);
                    stan::math::initialize(w, DUMMY_VAR__);
                    stan::math::fill(w,DUMMY_VAR__);


                    current_statement_begin__ = 392;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 395;
                    if (as_bool(logical_eq(UNCRT,0))) {

                        current_statement_begin__ = 396;
                        stan::math::assign(x_tilde, get_base1(X,3,"X",1));
                    } else {

                        current_statement_begin__ = 398;
                        stan::math::assign(x_tilde, get_x_tilde(get_base1(X,3,"X",1),get_base1(T_onset,1,"T_onset",1),T_observed,caseID_to_rows,caseID_nrows, pstream__));
                    }
                    current_statement_begin__ = 400;
                    stan::math::assign(w, to_array_1d(warp_input(x_tilde,stp,0.0,1.0, pstream__)));
                    current_statement_begin__ = 403;
                    stan::math::assign(Kxr, elt_multiply(get_base1(KF,2,"KF",1),cov_exp_quad(w,alp,ell)));
                    current_statement_begin__ = 404;
                    if (as_bool(logical_eq(HMGNS,0))) {

                        current_statement_begin__ = 405;
                        stan::math::assign(Kxr, stan::model::deep_copy(elt_multiply(K_beta(get_base1(beta,1,"beta",1),row_to_caseID, pstream__),Kxr)));
                    }
                    current_statement_begin__ = 407;
                    if (as_bool(logical_eq(USE_VAR_MASK,1))) {

                        current_statement_begin__ = 408;
                        stan::math::assign(Kxr, stan::model::deep_copy(elt_multiply(K_var_mask(x_tilde,stp,vm_params, pstream__),Kxr)));
                    }
                    current_statement_begin__ = 410;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 411;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                    }
                }
                current_statement_begin__ = 413;
                for (int j = 1; j <= get_base1(D,4,"D",1); ++j) {

                    current_statement_begin__ = 414;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 415;
                    stan::math::assign(Kxr, cov_exp_quad(to_array_1d(get_base1(X,((2 + get_base1(D,3,"D",1)) + j),"X",1)),get_base1(alpha_continuous,j,"alpha_continuous",1),get_base1(lengthscale_continuous,j,"lengthscale_continuous",1)));
                    current_statement_begin__ = 416;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 417;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 419;
                for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {

                    current_statement_begin__ = 420;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 421;
                    stan::math::assign(Kxr, elt_multiply(cov_exp_quad(x_age,get_base1(alpha_categAge,j,"alpha_categAge",1),get_base1(lengthscale_categAge,j,"lengthscale_categAge",1)),get_base1(KF,((1 + get_base1(D,3,"D",1)) + j),"KF",1)));
                    current_statement_begin__ = 422;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 423;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 425;
                for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {

                    current_statement_begin__ = 426;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 427;
                    stan::math::assign(Kxr, multiply(square(get_base1(alpha_categOffset,j,"alpha_categOffset",1)),get_base1(KF,(((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + j),"KF",1)));
                    current_statement_begin__ = 428;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 429;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < UNCRT; ++i0__) {
                for (int i1__ = 0; i1__ < N_cases; ++i1__) {
                    if (stan::math::is_uninitialized(T_onset[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: T_onset" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < F_is_sampled; ++i0__) {
                for (int i1__ = 0; i1__ < sum_D; ++i1__) {
                    for (int i2__ = 0; i2__ < n_tot; ++i2__) {
                        if (stan::math::is_uninitialized(F[i0__][i1__](i2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: F" << '[' << i0__ << ']' << '[' << i1__ << ']' << '[' << i2__ << ']';
                            throw std::runtime_error(msg__.str());
                        }
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 362;
            current_statement_begin__ = 363;

            // model body

            current_statement_begin__ = 440;
            if (as_bool(logical_eq(get_base1(D,1,"D",1),1))) {

                current_statement_begin__ = 441;
                lp_accum__.add(log_prior(get_base1(alpha_idAge,1,"alpha_idAge",1),stan::model::rvalue(t_ID, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_ID"),stan::model::rvalue(p_ID, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_ID"), pstream__));
                current_statement_begin__ = 442;
                lp_accum__.add(log_prior(get_base1(lengthscale_idAge,1,"lengthscale_idAge",1),stan::model::rvalue(t_ID, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list())), "t_ID"),stan::model::rvalue(p_ID, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(4, 6), stan::model::nil_index_list())), "p_ID"), pstream__));
            }
            current_statement_begin__ = 446;
            if (as_bool(logical_eq(get_base1(D,2,"D",1),1))) {

                current_statement_begin__ = 447;
                lp_accum__.add(log_prior(get_base1(alpha_sharedAge,1,"alpha_sharedAge",1),stan::model::rvalue(t_A, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_A"),stan::model::rvalue(p_A, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_A"), pstream__));
                current_statement_begin__ = 448;
                lp_accum__.add(log_prior(get_base1(lengthscale_sharedAge,1,"lengthscale_sharedAge",1),stan::model::rvalue(t_A, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list())), "t_A"),stan::model::rvalue(p_A, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(4, 6), stan::model::nil_index_list())), "p_A"), pstream__));
            }
            current_statement_begin__ = 452;
            if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {

                current_statement_begin__ = 453;
                lp_accum__.add(log_prior(get_base1(alpha_diseaseAge,1,"alpha_diseaseAge",1),stan::model::rvalue(t_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_D"),stan::model::rvalue(p_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_D"), pstream__));
                current_statement_begin__ = 454;
                lp_accum__.add(log_prior(get_base1(lengthscale_diseaseAge,1,"lengthscale_diseaseAge",1),stan::model::rvalue(t_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list())), "t_D"),stan::model::rvalue(p_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(4, 6), stan::model::nil_index_list())), "p_D"), pstream__));
                current_statement_begin__ = 455;
                lp_accum__.add(log_prior(get_base1(warp_steepness,1,"warp_steepness",1),stan::model::rvalue(t_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(5, 6), stan::model::nil_index_list())), "t_D"),stan::model::rvalue(p_D, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_min_max(7, 9), stan::model::nil_index_list())), "p_D"), pstream__));
            }
            current_statement_begin__ = 459;
            for (int j = 1; j <= get_base1(D,4,"D",1); ++j) {

                current_statement_begin__ = 460;
                lp_accum__.add(log_prior(get_base1(alpha_continuous,j,"alpha_continuous",1),stan::model::rvalue(t_CNT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_CNT"),stan::model::rvalue(p_CNT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_CNT"), pstream__));
                current_statement_begin__ = 461;
                lp_accum__.add(log_prior(get_base1(lengthscale_continuous,j,"lengthscale_continuous",1),stan::model::rvalue(t_CNT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list())), "t_CNT"),stan::model::rvalue(p_CNT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(4, 6), stan::model::nil_index_list())), "p_CNT"), pstream__));
            }
            current_statement_begin__ = 465;
            for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {

                current_statement_begin__ = 466;
                lp_accum__.add(log_prior(get_base1(alpha_categAge,j,"alpha_categAge",1),stan::model::rvalue(t_CAT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_CAT"),stan::model::rvalue(p_CAT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_CAT"), pstream__));
                current_statement_begin__ = 467;
                lp_accum__.add(log_prior(get_base1(lengthscale_categAge,j,"lengthscale_categAge",1),stan::model::rvalue(t_CAT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(3, 4), stan::model::nil_index_list())), "t_CAT"),stan::model::rvalue(p_CAT, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(4, 6), stan::model::nil_index_list())), "p_CAT"), pstream__));
            }
            current_statement_begin__ = 471;
            for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {

                current_statement_begin__ = 472;
                lp_accum__.add(log_prior(get_base1(alpha_categOffset,j,"alpha_categOffset",1),stan::model::rvalue(t_OFS, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_OFS"),stan::model::rvalue(p_OFS, stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_OFS"), pstream__));
            }
            current_statement_begin__ = 476;
            if (as_bool(logical_eq(LH,1))) {

                current_statement_begin__ = 477;
                lp_accum__.add(log_prior(get_base1(sigma_n,1,"sigma_n",1),stan::model::rvalue(t_SIG, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "t_SIG"),stan::model::rvalue(p_SIG, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "p_SIG"), pstream__));
            } else if (as_bool(logical_eq(LH,3))) {

                current_statement_begin__ = 479;
                lp_accum__.add(log_prior(get_base1(phi,1,"phi",1),stan::model::rvalue(t_PHI, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "t_PHI"),stan::model::rvalue(p_PHI, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "p_PHI"), pstream__));
            } else if (as_bool(logical_eq(LH,0))) {

                current_statement_begin__ = 481;
                lp_accum__.add(log_prior(get_base1(sigma_n,1,"sigma_n",1),stan::model::rvalue(t_SIG, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "t_SIG"),stan::model::rvalue(p_SIG, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "p_SIG"), pstream__));
                current_statement_begin__ = 482;
                lp_accum__.add(log_prior(get_base1(phi,1,"phi",1),stan::model::rvalue(t_PHI, stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list()), "t_PHI"),stan::model::rvalue(p_PHI, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "p_PHI"), pstream__));
            }
            current_statement_begin__ = 486;
            if (as_bool(UNCRT)) {
                {
                current_statement_begin__ = 487;
                local_scalar_t__ tx;
                (void) tx;  // dummy to suppress unused var warning

                stan::math::initialize(tx, DUMMY_VAR__);
                stan::math::fill(tx,DUMMY_VAR__);


                current_statement_begin__ = 488;
                for (int k = 1; k <= N_cases; ++k) {

                    current_statement_begin__ = 489;
                    if (as_bool(logical_eq(backwards,1))) {

                        current_statement_begin__ = 490;
                        stan::math::assign(tx, (get_base1(T_observed,k,"T_observed",1) - get_base1(get_base1(T_onset,1,"T_onset",1),k,"T_onset",2)));
                    } else {

                        current_statement_begin__ = 492;
                        stan::math::assign(tx, get_base1(get_base1(T_onset,1,"T_onset",1),k,"T_onset",2));
                    }
                    current_statement_begin__ = 494;
                    lp_accum__.add(log_prior(tx,stan::model::rvalue(t_ONS, stan::model::cons_list(stan::model::index_uni(k), stan::model::cons_list(stan::model::index_min_max(1, 2), stan::model::nil_index_list())), "t_ONS"),stan::model::rvalue(p_ONS, stan::model::cons_list(stan::model::index_uni(k), stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list())), "p_ONS"), pstream__));
                }
                }
            }
            current_statement_begin__ = 499;
            if (as_bool(logical_eq(HMGNS,0))) {

                current_statement_begin__ = 500;
                lp_accum__.add(beta_log<propto__>(get_base1(beta,1,"beta",1), get_base1(p_BET,1,"p_BET",1), get_base1(p_BET,2,"p_BET",1)));
            }
            current_statement_begin__ = 504;
            if (as_bool(F_is_sampled)) {

                current_statement_begin__ = 505;
                for (int j = 1; j <= sum_D; ++j) {

                    current_statement_begin__ = 506;
                    lp_accum__.add(normal_log<propto__>(get_base1(get_base1(ETA,1,"ETA",1),j,"ETA",2), 0, 1));
                }
            }
            current_statement_begin__ = 512;
            if (as_bool(logical_eq(LH,0))) {

            } else {

                current_statement_begin__ = 516;
                if (as_bool(F_is_sampled)) {
                    {
                    current_statement_begin__ = 520;
                    validate_non_negative_index("F_sum", "n_tot", n_tot);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  F_sum(static_cast<Eigen::VectorXd::Index>(n_tot));
                    (void) F_sum;  // dummy to suppress unused var warning

                    stan::math::initialize(F_sum, DUMMY_VAR__);
                    stan::math::fill(F_sum,DUMMY_VAR__);
                    stan::math::assign(F_sum,rep_vector(0,n_tot));


                    current_statement_begin__ = 521;
                    for (int i = 1; i <= n_tot; ++i) {

                        current_statement_begin__ = 522;
                        stan::model::assign(F_sum, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                                    (stan::model::rvalue(F_sum, stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), "F_sum") + sum(stan::model::rvalue(F, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()))), "F"))), 
                                    "assigning variable F_sum");
                    }
                    current_statement_begin__ = 526;
                    if (as_bool(logical_eq(LH,1))) {

                        current_statement_begin__ = 528;
                        lp_accum__.add(normal_log<propto__>(y, stan::model::rvalue(F_sum, stan::model::cons_list(stan::model::index_min_max(1, n), stan::model::nil_index_list()), "F_sum"), rep_vector(get_base1(sigma_n,1,"sigma_n",1),n)));
                    } else {
                        {
                        current_statement_begin__ = 530;
                        validate_non_negative_index("log_g", "n", n);
                        vector<local_scalar_t__> log_g(n);
                        stan::math::initialize(log_g, DUMMY_VAR__);
                        stan::math::fill(log_g,DUMMY_VAR__);
                        stan::math::assign(log_g,to_array_1d(add(stan::model::rvalue(F_sum, stan::model::cons_list(stan::model::index_min_max(1, n), stan::model::nil_index_list()), "F_sum"),C_hat)));


                        current_statement_begin__ = 531;
                        if (as_bool(logical_eq(LH,2))) {

                            current_statement_begin__ = 533;
                            lp_accum__.add(poisson_log_log<propto__>(y_int, log_g));
                        } else if (as_bool(logical_eq(LH,3))) {

                            current_statement_begin__ = 536;
                            lp_accum__.add(neg_binomial_2_log_log<propto__>(y_int, log_g, rep_vector(get_base1(phi,1,"phi",1),n)));
                        } else {

                            current_statement_begin__ = 538;
                            std::stringstream errmsg_stream__;
                            errmsg_stream__ << "Unknown likelihood!";
                            throw std::domain_error(errmsg_stream__.str());
                        }
                        }
                    }
                    }
                } else {
                    {
                    current_statement_begin__ = 546;
                    validate_non_negative_index("Kx", "n", n);
                    validate_non_negative_index("Kx", "n", n);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Kx(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                    (void) Kx;  // dummy to suppress unused var warning

                    stan::math::initialize(Kx, DUMMY_VAR__);
                    stan::math::fill(Kx,DUMMY_VAR__);
                    stan::math::assign(Kx,rep_matrix(0,n,n));
                    current_statement_begin__ = 547;
                    validate_non_negative_index("KX", "n", n);
                    validate_non_negative_index("KX", "n", n);
                    validate_non_negative_index("KX", "sum_D", sum_D);
                    vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > KX(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n))));
                    stan::math::initialize(KX, DUMMY_VAR__);
                    stan::math::fill(KX,DUMMY_VAR__);
                    current_statement_begin__ = 548;
                    validate_non_negative_index("Ky", "n", n);
                    validate_non_negative_index("Ky", "n", n);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Ky(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                    (void) Ky;  // dummy to suppress unused var warning

                    stan::math::initialize(Ky, DUMMY_VAR__);
                    stan::math::fill(Ky,DUMMY_VAR__);
                    current_statement_begin__ = 549;
                    validate_non_negative_index("Ly", "n", n);
                    validate_non_negative_index("Ly", "n", n);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Ly(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                    (void) Ly;  // dummy to suppress unused var warning

                    stan::math::initialize(Ly, DUMMY_VAR__);
                    stan::math::fill(Ly,DUMMY_VAR__);
                    current_statement_begin__ = 550;
                    int r(0);
                    (void) r;  // dummy to suppress unused var warning

                    stan::math::fill(r, std::numeric_limits<int>::min());
                    stan::math::assign(r,0);


                    current_statement_begin__ = 551;
                    if (as_bool(logical_eq(get_base1(D,1,"D",1),1))) {
                        {
                        current_statement_begin__ = 552;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_idAge,1,"alpha_idAge",1));
                        current_statement_begin__ = 553;
                        local_scalar_t__ ell;
                        (void) ell;  // dummy to suppress unused var warning

                        stan::math::initialize(ell, DUMMY_VAR__);
                        stan::math::fill(ell,DUMMY_VAR__);
                        stan::math::assign(ell,get_base1(lengthscale_idAge,1,"lengthscale_idAge",1));


                        current_statement_begin__ = 554;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 555;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    elt_multiply(cov_exp_quad(x_age,alp,ell),get_base1(KF,1,"KF",1)), 
                                    "assigning variable KX");
                        }
                    }
                    current_statement_begin__ = 557;
                    if (as_bool(logical_eq(get_base1(D,2,"D",1),1))) {
                        {
                        current_statement_begin__ = 558;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_sharedAge,1,"alpha_sharedAge",1));
                        current_statement_begin__ = 559;
                        local_scalar_t__ ell;
                        (void) ell;  // dummy to suppress unused var warning

                        stan::math::initialize(ell, DUMMY_VAR__);
                        stan::math::fill(ell,DUMMY_VAR__);
                        stan::math::assign(ell,get_base1(lengthscale_sharedAge,1,"lengthscale_sharedAge",1));


                        current_statement_begin__ = 560;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 561;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    cov_exp_quad(x_age,alp,ell), 
                                    "assigning variable KX");
                        }
                    }
                    current_statement_begin__ = 563;
                    if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {
                        {
                        current_statement_begin__ = 564;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_diseaseAge,1,"alpha_diseaseAge",1));
                        current_statement_begin__ = 565;
                        local_scalar_t__ ell;
                        (void) ell;  // dummy to suppress unused var warning

                        stan::math::initialize(ell, DUMMY_VAR__);
                        stan::math::fill(ell,DUMMY_VAR__);
                        stan::math::assign(ell,get_base1(lengthscale_diseaseAge,1,"lengthscale_diseaseAge",1));
                        current_statement_begin__ = 566;
                        local_scalar_t__ stp;
                        (void) stp;  // dummy to suppress unused var warning

                        stan::math::initialize(stp, DUMMY_VAR__);
                        stan::math::fill(stp,DUMMY_VAR__);
                        stan::math::assign(stp,get_base1(warp_steepness,1,"warp_steepness",1));
                        current_statement_begin__ = 567;
                        validate_non_negative_index("x_tilde", "n", n);
                        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  x_tilde(static_cast<Eigen::VectorXd::Index>(n));
                        (void) x_tilde;  // dummy to suppress unused var warning

                        stan::math::initialize(x_tilde, DUMMY_VAR__);
                        stan::math::fill(x_tilde,DUMMY_VAR__);
                        current_statement_begin__ = 568;
                        validate_non_negative_index("w", "n", n);
                        vector<local_scalar_t__> w(n);
                        stan::math::initialize(w, DUMMY_VAR__);
                        stan::math::fill(w,DUMMY_VAR__);


                        current_statement_begin__ = 569;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 572;
                        if (as_bool(logical_eq(UNCRT,0))) {

                            current_statement_begin__ = 573;
                            stan::math::assign(x_tilde, get_base1(X,3,"X",1));
                        } else {

                            current_statement_begin__ = 575;
                            stan::math::assign(x_tilde, get_x_tilde(get_base1(X,3,"X",1),get_base1(T_onset,1,"T_onset",1),T_observed,caseID_to_rows,caseID_nrows, pstream__));
                        }
                        current_statement_begin__ = 577;
                        stan::math::assign(w, to_array_1d(warp_input(x_tilde,stp,0.0,1.0, pstream__)));
                        current_statement_begin__ = 580;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    elt_multiply(get_base1(KF,2,"KF",1),cov_exp_quad(w,alp,ell)), 
                                    "assigning variable KX");
                        current_statement_begin__ = 581;
                        if (as_bool(logical_eq(HMGNS,0))) {

                            current_statement_begin__ = 582;
                            stan::model::assign(KX, 
                                        stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                        stan::model::deep_copy(elt_multiply(K_beta(get_base1(beta,1,"beta",1),row_to_caseID, pstream__),get_base1(KX,r,"KX",1))), 
                                        "assigning variable KX");
                        }
                        current_statement_begin__ = 584;
                        if (as_bool(logical_eq(USE_VAR_MASK,1))) {

                            current_statement_begin__ = 585;
                            stan::model::assign(KX, 
                                        stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                        stan::model::deep_copy(elt_multiply(K_var_mask(x_tilde,stp,vm_params, pstream__),get_base1(KX,r,"KX",1))), 
                                        "assigning variable KX");
                        }
                        }
                    }
                    current_statement_begin__ = 588;
                    for (int j = 1; j <= get_base1(D,4,"D",1); ++j) {
                        {
                        current_statement_begin__ = 589;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_continuous,j,"alpha_continuous",1));
                        current_statement_begin__ = 590;
                        local_scalar_t__ ell;
                        (void) ell;  // dummy to suppress unused var warning

                        stan::math::initialize(ell, DUMMY_VAR__);
                        stan::math::fill(ell,DUMMY_VAR__);
                        stan::math::assign(ell,get_base1(lengthscale_continuous,j,"lengthscale_continuous",1));
                        current_statement_begin__ = 591;
                        int ix(0);
                        (void) ix;  // dummy to suppress unused var warning

                        stan::math::fill(ix, std::numeric_limits<int>::min());
                        stan::math::assign(ix,((2 + get_base1(D,3,"D",1)) + j));


                        current_statement_begin__ = 592;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 593;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    cov_exp_quad(to_array_1d(get_base1(X,ix,"X",1)),alp,ell), 
                                    "assigning variable KX");
                        }
                    }
                    current_statement_begin__ = 595;
                    for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {
                        {
                        current_statement_begin__ = 596;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_categAge,j,"alpha_categAge",1));
                        current_statement_begin__ = 597;
                        local_scalar_t__ ell;
                        (void) ell;  // dummy to suppress unused var warning

                        stan::math::initialize(ell, DUMMY_VAR__);
                        stan::math::fill(ell,DUMMY_VAR__);
                        stan::math::assign(ell,get_base1(lengthscale_categAge,j,"lengthscale_categAge",1));
                        current_statement_begin__ = 598;
                        int ikf(0);
                        (void) ikf;  // dummy to suppress unused var warning

                        stan::math::fill(ikf, std::numeric_limits<int>::min());
                        stan::math::assign(ikf,((1 + get_base1(D,3,"D",1)) + j));


                        current_statement_begin__ = 599;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 600;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    elt_multiply(cov_exp_quad(x_age,alp,ell),get_base1(KF,ikf,"KF",1)), 
                                    "assigning variable KX");
                        }
                    }
                    current_statement_begin__ = 602;
                    for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {
                        {
                        current_statement_begin__ = 603;
                        int ikf(0);
                        (void) ikf;  // dummy to suppress unused var warning

                        stan::math::fill(ikf, std::numeric_limits<int>::min());
                        stan::math::assign(ikf,(((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + j));
                        current_statement_begin__ = 604;
                        local_scalar_t__ alp;
                        (void) alp;  // dummy to suppress unused var warning

                        stan::math::initialize(alp, DUMMY_VAR__);
                        stan::math::fill(alp,DUMMY_VAR__);
                        stan::math::assign(alp,get_base1(alpha_categOffset,j,"alpha_categOffset",1));


                        current_statement_begin__ = 605;
                        stan::math::assign(r, (r + 1));
                        current_statement_begin__ = 606;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    multiply(square(alp),get_base1(KF,ikf,"KF",1)), 
                                    "assigning variable KX");
                        }
                    }
                    current_statement_begin__ = 610;
                    for (int j = 1; j <= sum_D; ++j) {

                        current_statement_begin__ = 611;
                        stan::math::assign(Kx, add(Kx, get_base1(KX,j,"KX",1)));
                    }
                    current_statement_begin__ = 615;
                    stan::math::assign(Kx, add(Kx, diag_matrix(rep_vector(DELTA,n))));
                    current_statement_begin__ = 618;
                    stan::math::assign(Ky, add(Kx,diag_matrix(rep_vector(square(get_base1(sigma_n,1,"sigma_n",1)),n))));
                    current_statement_begin__ = 619;
                    stan::math::assign(Ly, cholesky_decompose(Ky));
                    current_statement_begin__ = 622;
                    if (as_bool(logical_neq(LH,1))) {

                        current_statement_begin__ = 623;
                        std::stringstream errmsg_stream__;
                        errmsg_stream__ << "Likelihood must be Gaussian if F is not sampled!";
                        throw std::domain_error(errmsg_stream__.str());
                    }
                    current_statement_begin__ = 625;
                    lp_accum__.add(multi_normal_cholesky_log<propto__>(y, mu, Ly));
                    }
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("alpha_idAge");
        names__.push_back("alpha_sharedAge");
        names__.push_back("alpha_diseaseAge");
        names__.push_back("alpha_continuous");
        names__.push_back("alpha_categAge");
        names__.push_back("alpha_categOffset");
        names__.push_back("lengthscale_idAge");
        names__.push_back("lengthscale_sharedAge");
        names__.push_back("lengthscale_diseaseAge");
        names__.push_back("lengthscale_continuous");
        names__.push_back("lengthscale_categAge");
        names__.push_back("warp_steepness");
        names__.push_back("sigma_n");
        names__.push_back("ETA");
        names__.push_back("phi");
        names__.push_back("beta");
        names__.push_back("T_raw");
        names__.push_back("T_onset");
        names__.push_back("F");
        names__.push_back("F_mean_cmp");
        names__.push_back("F_var_cmp");
        names__.push_back("F_mean_tot");
        names__.push_back("F_var_tot");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(get_base1(D,1,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,2,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,3,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,4,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,5,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,6,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,1,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,2,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,3,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,4,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,5,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(get_base1(D,3,"D",1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(F_is_sampled);
        dims__.push_back(sum_D);
        dims__.push_back(n_tot);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(HMGNS,0));
        dims__.push_back(N_cases);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(UNCRT,1));
        dims__.push_back(N_cases);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(UNCRT);
        dims__.push_back(N_cases);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(F_is_sampled);
        dims__.push_back(sum_D);
        dims__.push_back(n_tot);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((1 - F_is_sampled));
        dims__.push_back(sum_D);
        dims__.push_back(n);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((1 - F_is_sampled));
        dims__.push_back(sum_D);
        dims__.push_back(n);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((1 - F_is_sampled));
        dims__.push_back(n);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((1 - F_is_sampled));
        dims__.push_back(n);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;

        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__,params_i__);
        static const char* function__ = "model_lgp_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector<double> alpha_idAge;
        size_t dim_alpha_idAge_0__ = get_base1(D,1,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_idAge_0__; ++k_0__) {
            alpha_idAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> alpha_sharedAge;
        size_t dim_alpha_sharedAge_0__ = get_base1(D,2,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_sharedAge_0__; ++k_0__) {
            alpha_sharedAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> alpha_diseaseAge;
        size_t dim_alpha_diseaseAge_0__ = get_base1(D,3,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_diseaseAge_0__; ++k_0__) {
            alpha_diseaseAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> alpha_continuous;
        size_t dim_alpha_continuous_0__ = get_base1(D,4,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_continuous_0__; ++k_0__) {
            alpha_continuous.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> alpha_categAge;
        size_t dim_alpha_categAge_0__ = get_base1(D,5,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_categAge_0__; ++k_0__) {
            alpha_categAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> alpha_categOffset;
        size_t dim_alpha_categOffset_0__ = get_base1(D,6,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_alpha_categOffset_0__; ++k_0__) {
            alpha_categOffset.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lengthscale_idAge;
        size_t dim_lengthscale_idAge_0__ = get_base1(D,1,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_lengthscale_idAge_0__; ++k_0__) {
            lengthscale_idAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lengthscale_sharedAge;
        size_t dim_lengthscale_sharedAge_0__ = get_base1(D,2,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_lengthscale_sharedAge_0__; ++k_0__) {
            lengthscale_sharedAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lengthscale_diseaseAge;
        size_t dim_lengthscale_diseaseAge_0__ = get_base1(D,3,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_lengthscale_diseaseAge_0__; ++k_0__) {
            lengthscale_diseaseAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lengthscale_continuous;
        size_t dim_lengthscale_continuous_0__ = get_base1(D,4,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_lengthscale_continuous_0__; ++k_0__) {
            lengthscale_continuous.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> lengthscale_categAge;
        size_t dim_lengthscale_categAge_0__ = get_base1(D,5,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_lengthscale_categAge_0__; ++k_0__) {
            lengthscale_categAge.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> warp_steepness;
        size_t dim_warp_steepness_0__ = get_base1(D,3,"D",1);
        for (size_t k_0__ = 0; k_0__ < dim_warp_steepness_0__; ++k_0__) {
            warp_steepness.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> sigma_n;
        size_t dim_sigma_n_0__ = (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0)));
        for (size_t k_0__ = 0; k_0__ < dim_sigma_n_0__; ++k_0__) {
            sigma_n.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector<vector_d> > ETA;
        size_t dim_ETA_0__ = F_is_sampled;
        ETA.resize(dim_ETA_0__);
        for (size_t k_0__ = 0; k_0__ < dim_ETA_0__; ++k_0__) {
            size_t dim_ETA_1__ = sum_D;
            for (size_t k_1__ = 0; k_1__ < dim_ETA_1__; ++k_1__) {
                ETA[k_0__].push_back(in__.vector_constrain(n_tot));
            }
        }
        vector<double> phi;
        size_t dim_phi_0__ = (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0)));
        for (size_t k_0__ = 0; k_0__ < dim_phi_0__; ++k_0__) {
            phi.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector_d> beta;
        size_t dim_beta_0__ = logical_eq(HMGNS,0);
        for (size_t k_0__ = 0; k_0__ < dim_beta_0__; ++k_0__) {
            beta.push_back(in__.vector_lub_constrain(0,1,N_cases));
        }
        vector<vector_d> T_raw;
        size_t dim_T_raw_0__ = logical_eq(UNCRT,1);
        for (size_t k_0__ = 0; k_0__ < dim_T_raw_0__; ++k_0__) {
            T_raw.push_back(in__.vector_lub_constrain(0,1,N_cases));
        }
            for (int k_0__ = 0; k_0__ < get_base1(D,1,"D",1); ++k_0__) {
            vars__.push_back(alpha_idAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,2,"D",1); ++k_0__) {
            vars__.push_back(alpha_sharedAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,3,"D",1); ++k_0__) {
            vars__.push_back(alpha_diseaseAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,4,"D",1); ++k_0__) {
            vars__.push_back(alpha_continuous[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,5,"D",1); ++k_0__) {
            vars__.push_back(alpha_categAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,6,"D",1); ++k_0__) {
            vars__.push_back(alpha_categOffset[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,1,"D",1); ++k_0__) {
            vars__.push_back(lengthscale_idAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,2,"D",1); ++k_0__) {
            vars__.push_back(lengthscale_sharedAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,3,"D",1); ++k_0__) {
            vars__.push_back(lengthscale_diseaseAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,4,"D",1); ++k_0__) {
            vars__.push_back(lengthscale_continuous[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,5,"D",1); ++k_0__) {
            vars__.push_back(lengthscale_categAge[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < get_base1(D,3,"D",1); ++k_0__) {
            vars__.push_back(warp_steepness[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            vars__.push_back(sigma_n[k_0__]);
            }
            for (int k_2__ = 0; k_2__ < n_tot; ++k_2__) {
                for (int k_1__ = 0; k_1__ < sum_D; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < F_is_sampled; ++k_0__) {
                    vars__.push_back(ETA[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_0__ = 0; k_0__ < (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            vars__.push_back(phi[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < N_cases; ++k_1__) {
                for (int k_0__ = 0; k_0__ < logical_eq(HMGNS,0); ++k_0__) {
                vars__.push_back(beta[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < N_cases; ++k_1__) {
                for (int k_0__ = 0; k_0__ < logical_eq(UNCRT,1); ++k_0__) {
                vars__.push_back(T_raw[k_0__][k_1__]);
                }
            }

        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 362;
            validate_non_negative_index("T_onset", "N_cases", N_cases);
            validate_non_negative_index("T_onset", "UNCRT", UNCRT);
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > T_onset(UNCRT, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(N_cases))));
            stan::math::initialize(T_onset, DUMMY_VAR__);
            stan::math::fill(T_onset,DUMMY_VAR__);
            current_statement_begin__ = 363;
            validate_non_negative_index("F", "n_tot", n_tot);
            validate_non_negative_index("F", "F_is_sampled", F_is_sampled);
            validate_non_negative_index("F", "sum_D", sum_D);
            vector<vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > > F(F_is_sampled, (vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> >(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n_tot))))));
            stan::math::initialize(F, DUMMY_VAR__);
            stan::math::fill(F,DUMMY_VAR__);


            current_statement_begin__ = 364;
            if (as_bool(UNCRT)) {

                current_statement_begin__ = 365;
                stan::model::assign(T_onset, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            add(get_base1(L_ons,1,"L_ons",1),elt_multiply(subtract(get_base1(U_ons,1,"U_ons",1),get_base1(L_ons,1,"L_ons",1)),get_base1(T_raw,1,"T_raw",1))), 
                            "assigning variable T_onset");
            }
            current_statement_begin__ = 367;
            if (as_bool(F_is_sampled)) {
                {
                current_statement_begin__ = 370;
                validate_non_negative_index("Kxr", "n_tot", n_tot);
                validate_non_negative_index("Kxr", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Kxr(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) Kxr;  // dummy to suppress unused var warning

                stan::math::initialize(Kxr, DUMMY_VAR__);
                stan::math::fill(Kxr,DUMMY_VAR__);
                current_statement_begin__ = 371;
                validate_non_negative_index("Lxr", "n_tot", n_tot);
                validate_non_negative_index("Lxr", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Lxr(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) Lxr;  // dummy to suppress unused var warning

                stan::math::initialize(Lxr, DUMMY_VAR__);
                stan::math::fill(Lxr,DUMMY_VAR__);
                current_statement_begin__ = 372;
                validate_non_negative_index("EYE", "n_tot", n_tot);
                validate_non_negative_index("EYE", "n_tot", n_tot);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  EYE(static_cast<Eigen::VectorXd::Index>(n_tot),static_cast<Eigen::VectorXd::Index>(n_tot));
                (void) EYE;  // dummy to suppress unused var warning

                stan::math::initialize(EYE, DUMMY_VAR__);
                stan::math::fill(EYE,DUMMY_VAR__);
                stan::math::assign(EYE,diag_matrix(rep_vector(DELTA,n_tot)));
                current_statement_begin__ = 373;
                int r(0);
                (void) r;  // dummy to suppress unused var warning

                stan::math::fill(r, std::numeric_limits<int>::min());
                stan::math::assign(r,0);


                current_statement_begin__ = 374;
                if (as_bool(logical_eq(get_base1(D,1,"D",1),1))) {

                    current_statement_begin__ = 375;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 376;
                    stan::math::assign(Kxr, elt_multiply(cov_exp_quad(x_age,get_base1(alpha_idAge,1,"alpha_idAge",1),get_base1(lengthscale_idAge,1,"lengthscale_idAge",1)),get_base1(KF,1,"KF",1)));
                    current_statement_begin__ = 377;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 378;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 380;
                if (as_bool(logical_eq(get_base1(D,2,"D",1),1))) {

                    current_statement_begin__ = 381;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 382;
                    stan::math::assign(Kxr, cov_exp_quad(x_age,get_base1(alpha_sharedAge,1,"alpha_sharedAge",1),get_base1(lengthscale_sharedAge,1,"lengthscale_sharedAge",1)));
                    current_statement_begin__ = 383;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 384;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 386;
                if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {
                    {
                    current_statement_begin__ = 387;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_diseaseAge,1,"alpha_diseaseAge",1));
                    current_statement_begin__ = 388;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_diseaseAge,1,"lengthscale_diseaseAge",1));
                    current_statement_begin__ = 389;
                    local_scalar_t__ stp;
                    (void) stp;  // dummy to suppress unused var warning

                    stan::math::initialize(stp, DUMMY_VAR__);
                    stan::math::fill(stp,DUMMY_VAR__);
                    stan::math::assign(stp,get_base1(warp_steepness,1,"warp_steepness",1));
                    current_statement_begin__ = 390;
                    validate_non_negative_index("x_tilde", "n_tot", n_tot);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  x_tilde(static_cast<Eigen::VectorXd::Index>(n_tot));
                    (void) x_tilde;  // dummy to suppress unused var warning

                    stan::math::initialize(x_tilde, DUMMY_VAR__);
                    stan::math::fill(x_tilde,DUMMY_VAR__);
                    current_statement_begin__ = 391;
                    validate_non_negative_index("w", "n_tot", n_tot);
                    vector<local_scalar_t__> w(n_tot);
                    stan::math::initialize(w, DUMMY_VAR__);
                    stan::math::fill(w,DUMMY_VAR__);


                    current_statement_begin__ = 392;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 395;
                    if (as_bool(logical_eq(UNCRT,0))) {

                        current_statement_begin__ = 396;
                        stan::math::assign(x_tilde, get_base1(X,3,"X",1));
                    } else {

                        current_statement_begin__ = 398;
                        stan::math::assign(x_tilde, get_x_tilde(get_base1(X,3,"X",1),get_base1(T_onset,1,"T_onset",1),T_observed,caseID_to_rows,caseID_nrows, pstream__));
                    }
                    current_statement_begin__ = 400;
                    stan::math::assign(w, to_array_1d(warp_input(x_tilde,stp,0.0,1.0, pstream__)));
                    current_statement_begin__ = 403;
                    stan::math::assign(Kxr, elt_multiply(get_base1(KF,2,"KF",1),cov_exp_quad(w,alp,ell)));
                    current_statement_begin__ = 404;
                    if (as_bool(logical_eq(HMGNS,0))) {

                        current_statement_begin__ = 405;
                        stan::math::assign(Kxr, stan::model::deep_copy(elt_multiply(K_beta(get_base1(beta,1,"beta",1),row_to_caseID, pstream__),Kxr)));
                    }
                    current_statement_begin__ = 407;
                    if (as_bool(logical_eq(USE_VAR_MASK,1))) {

                        current_statement_begin__ = 408;
                        stan::math::assign(Kxr, stan::model::deep_copy(elt_multiply(K_var_mask(x_tilde,stp,vm_params, pstream__),Kxr)));
                    }
                    current_statement_begin__ = 410;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 411;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                    }
                }
                current_statement_begin__ = 413;
                for (int j = 1; j <= get_base1(D,4,"D",1); ++j) {

                    current_statement_begin__ = 414;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 415;
                    stan::math::assign(Kxr, cov_exp_quad(to_array_1d(get_base1(X,((2 + get_base1(D,3,"D",1)) + j),"X",1)),get_base1(alpha_continuous,j,"alpha_continuous",1),get_base1(lengthscale_continuous,j,"lengthscale_continuous",1)));
                    current_statement_begin__ = 416;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 417;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 419;
                for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {

                    current_statement_begin__ = 420;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 421;
                    stan::math::assign(Kxr, elt_multiply(cov_exp_quad(x_age,get_base1(alpha_categAge,j,"alpha_categAge",1),get_base1(lengthscale_categAge,j,"lengthscale_categAge",1)),get_base1(KF,((1 + get_base1(D,3,"D",1)) + j),"KF",1)));
                    current_statement_begin__ = 422;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 423;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                current_statement_begin__ = 425;
                for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {

                    current_statement_begin__ = 426;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 427;
                    stan::math::assign(Kxr, multiply(square(get_base1(alpha_categOffset,j,"alpha_categOffset",1)),get_base1(KF,(((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + j),"KF",1)));
                    current_statement_begin__ = 428;
                    stan::math::assign(Lxr, cholesky_decompose(add(Kxr,EYE)));
                    current_statement_begin__ = 429;
                    stan::model::assign(F, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), 
                                multiply(Lxr,stan::model::rvalue(ETA, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(r), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()))), "ETA")), 
                                "assigning variable F");
                }
                }
            }

            // validate transformed parameters
            current_statement_begin__ = 362;
            current_statement_begin__ = 363;

            // write transformed parameters
            if (include_tparams__) {
            for (int k_1__ = 0; k_1__ < N_cases; ++k_1__) {
                for (int k_0__ = 0; k_0__ < UNCRT; ++k_0__) {
                vars__.push_back(T_onset[k_0__][k_1__]);
                }
            }
            for (int k_2__ = 0; k_2__ < n_tot; ++k_2__) {
                for (int k_1__ = 0; k_1__ < sum_D; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < F_is_sampled; ++k_0__) {
                    vars__.push_back(F[k_0__][k_1__][k_2__]);
                    }
                }
            }
            }
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 631;
            validate_non_negative_index("F_mean_cmp", "n", n);
            validate_non_negative_index("F_mean_cmp", "(1 - F_is_sampled)", (1 - F_is_sampled));
            validate_non_negative_index("F_mean_cmp", "sum_D", sum_D);
            vector<vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > > F_mean_cmp((1 - F_is_sampled), (vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> >(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n))))));
            stan::math::initialize(F_mean_cmp, DUMMY_VAR__);
            stan::math::fill(F_mean_cmp,DUMMY_VAR__);
            current_statement_begin__ = 632;
            validate_non_negative_index("F_var_cmp", "n", n);
            validate_non_negative_index("F_var_cmp", "(1 - F_is_sampled)", (1 - F_is_sampled));
            validate_non_negative_index("F_var_cmp", "sum_D", sum_D);
            vector<vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > > F_var_cmp((1 - F_is_sampled), (vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> >(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n))))));
            stan::math::initialize(F_var_cmp, DUMMY_VAR__);
            stan::math::fill(F_var_cmp,DUMMY_VAR__);
            current_statement_begin__ = 633;
            validate_non_negative_index("F_mean_tot", "n", n);
            validate_non_negative_index("F_mean_tot", "(1 - F_is_sampled)", (1 - F_is_sampled));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > F_mean_tot((1 - F_is_sampled), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n))));
            stan::math::initialize(F_mean_tot, DUMMY_VAR__);
            stan::math::fill(F_mean_tot,DUMMY_VAR__);
            current_statement_begin__ = 634;
            validate_non_negative_index("F_var_tot", "n", n);
            validate_non_negative_index("F_var_tot", "(1 - F_is_sampled)", (1 - F_is_sampled));
            vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> > F_var_tot((1 - F_is_sampled), (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(n))));
            stan::math::initialize(F_var_tot, DUMMY_VAR__);
            stan::math::fill(F_var_tot,DUMMY_VAR__);


            current_statement_begin__ = 636;
            if (as_bool(logical_eq(F_is_sampled,0))) {
                {
                current_statement_begin__ = 637;
                validate_non_negative_index("A", "n", n);
                validate_non_negative_index("A", "n", n);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  A(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                (void) A;  // dummy to suppress unused var warning

                stan::math::initialize(A, DUMMY_VAR__);
                stan::math::fill(A,DUMMY_VAR__);
                current_statement_begin__ = 638;
                validate_non_negative_index("v", "n", n);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  v(static_cast<Eigen::VectorXd::Index>(n));
                (void) v;  // dummy to suppress unused var warning

                stan::math::initialize(v, DUMMY_VAR__);
                stan::math::fill(v,DUMMY_VAR__);
                current_statement_begin__ = 640;
                validate_non_negative_index("Kx", "n", n);
                validate_non_negative_index("Kx", "n", n);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Kx(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                (void) Kx;  // dummy to suppress unused var warning

                stan::math::initialize(Kx, DUMMY_VAR__);
                stan::math::fill(Kx,DUMMY_VAR__);
                stan::math::assign(Kx,rep_matrix(0,n,n));
                current_statement_begin__ = 641;
                validate_non_negative_index("KX", "n", n);
                validate_non_negative_index("KX", "n", n);
                validate_non_negative_index("KX", "sum_D", sum_D);
                vector<Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> > KX(sum_D, (Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n))));
                stan::math::initialize(KX, DUMMY_VAR__);
                stan::math::fill(KX,DUMMY_VAR__);
                current_statement_begin__ = 642;
                validate_non_negative_index("Ky", "n", n);
                validate_non_negative_index("Ky", "n", n);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Ky(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                (void) Ky;  // dummy to suppress unused var warning

                stan::math::initialize(Ky, DUMMY_VAR__);
                stan::math::fill(Ky,DUMMY_VAR__);
                current_statement_begin__ = 643;
                validate_non_negative_index("Ly", "n", n);
                validate_non_negative_index("Ly", "n", n);
                Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Ly(static_cast<Eigen::VectorXd::Index>(n),static_cast<Eigen::VectorXd::Index>(n));
                (void) Ly;  // dummy to suppress unused var warning

                stan::math::initialize(Ly, DUMMY_VAR__);
                stan::math::fill(Ly,DUMMY_VAR__);
                current_statement_begin__ = 644;
                int r(0);
                (void) r;  // dummy to suppress unused var warning

                stan::math::fill(r, std::numeric_limits<int>::min());
                stan::math::assign(r,0);


                current_statement_begin__ = 645;
                if (as_bool(logical_eq(get_base1(D,1,"D",1),1))) {
                    {
                    current_statement_begin__ = 646;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_idAge,1,"alpha_idAge",1));
                    current_statement_begin__ = 647;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_idAge,1,"lengthscale_idAge",1));


                    current_statement_begin__ = 648;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 649;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                elt_multiply(cov_exp_quad(x_age,alp,ell),get_base1(KF,1,"KF",1)), 
                                "assigning variable KX");
                    }
                }
                current_statement_begin__ = 651;
                if (as_bool(logical_eq(get_base1(D,2,"D",1),1))) {
                    {
                    current_statement_begin__ = 652;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_sharedAge,1,"alpha_sharedAge",1));
                    current_statement_begin__ = 653;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_sharedAge,1,"lengthscale_sharedAge",1));


                    current_statement_begin__ = 654;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 655;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                cov_exp_quad(x_age,alp,ell), 
                                "assigning variable KX");
                    }
                }
                current_statement_begin__ = 657;
                if (as_bool(logical_eq(get_base1(D,3,"D",1),1))) {
                    {
                    current_statement_begin__ = 658;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_diseaseAge,1,"alpha_diseaseAge",1));
                    current_statement_begin__ = 659;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_diseaseAge,1,"lengthscale_diseaseAge",1));
                    current_statement_begin__ = 660;
                    local_scalar_t__ stp;
                    (void) stp;  // dummy to suppress unused var warning

                    stan::math::initialize(stp, DUMMY_VAR__);
                    stan::math::fill(stp,DUMMY_VAR__);
                    stan::math::assign(stp,get_base1(warp_steepness,1,"warp_steepness",1));
                    current_statement_begin__ = 661;
                    validate_non_negative_index("x_tilde", "n", n);
                    Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  x_tilde(static_cast<Eigen::VectorXd::Index>(n));
                    (void) x_tilde;  // dummy to suppress unused var warning

                    stan::math::initialize(x_tilde, DUMMY_VAR__);
                    stan::math::fill(x_tilde,DUMMY_VAR__);
                    current_statement_begin__ = 662;
                    validate_non_negative_index("w", "n", n);
                    vector<local_scalar_t__> w(n);
                    stan::math::initialize(w, DUMMY_VAR__);
                    stan::math::fill(w,DUMMY_VAR__);


                    current_statement_begin__ = 663;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 666;
                    if (as_bool(logical_eq(UNCRT,0))) {

                        current_statement_begin__ = 667;
                        stan::math::assign(x_tilde, get_base1(X,3,"X",1));
                    } else {

                        current_statement_begin__ = 669;
                        stan::math::assign(x_tilde, get_x_tilde(get_base1(X,3,"X",1),get_base1(T_onset,1,"T_onset",1),T_observed,caseID_to_rows,caseID_nrows, pstream__));
                    }
                    current_statement_begin__ = 671;
                    stan::math::assign(w, to_array_1d(warp_input(x_tilde,stp,0.0,1.0, pstream__)));
                    current_statement_begin__ = 674;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                elt_multiply(get_base1(KF,2,"KF",1),cov_exp_quad(w,alp,ell)), 
                                "assigning variable KX");
                    current_statement_begin__ = 675;
                    if (as_bool(logical_eq(HMGNS,0))) {

                        current_statement_begin__ = 676;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    stan::model::deep_copy(elt_multiply(K_beta(get_base1(beta,1,"beta",1),row_to_caseID, pstream__),get_base1(KX,r,"KX",1))), 
                                    "assigning variable KX");
                    }
                    current_statement_begin__ = 678;
                    if (as_bool(logical_eq(USE_VAR_MASK,1))) {

                        current_statement_begin__ = 679;
                        stan::model::assign(KX, 
                                    stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                    stan::model::deep_copy(elt_multiply(K_var_mask(x_tilde,stp,vm_params, pstream__),get_base1(KX,r,"KX",1))), 
                                    "assigning variable KX");
                    }
                    }
                }
                current_statement_begin__ = 682;
                for (int j = 1; j <= get_base1(D,4,"D",1); ++j) {
                    {
                    current_statement_begin__ = 683;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_continuous,j,"alpha_continuous",1));
                    current_statement_begin__ = 684;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_continuous,j,"lengthscale_continuous",1));
                    current_statement_begin__ = 685;
                    int ix(0);
                    (void) ix;  // dummy to suppress unused var warning

                    stan::math::fill(ix, std::numeric_limits<int>::min());
                    stan::math::assign(ix,((2 + get_base1(D,3,"D",1)) + j));


                    current_statement_begin__ = 686;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 687;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                cov_exp_quad(to_array_1d(get_base1(X,ix,"X",1)),alp,ell), 
                                "assigning variable KX");
                    }
                }
                current_statement_begin__ = 689;
                for (int j = 1; j <= get_base1(D,5,"D",1); ++j) {
                    {
                    current_statement_begin__ = 690;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_categAge,j,"alpha_categAge",1));
                    current_statement_begin__ = 691;
                    local_scalar_t__ ell;
                    (void) ell;  // dummy to suppress unused var warning

                    stan::math::initialize(ell, DUMMY_VAR__);
                    stan::math::fill(ell,DUMMY_VAR__);
                    stan::math::assign(ell,get_base1(lengthscale_categAge,j,"lengthscale_categAge",1));
                    current_statement_begin__ = 692;
                    int ikf(0);
                    (void) ikf;  // dummy to suppress unused var warning

                    stan::math::fill(ikf, std::numeric_limits<int>::min());
                    stan::math::assign(ikf,((1 + get_base1(D,3,"D",1)) + j));


                    current_statement_begin__ = 693;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 694;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                elt_multiply(cov_exp_quad(x_age,alp,ell),get_base1(KF,ikf,"KF",1)), 
                                "assigning variable KX");
                    }
                }
                current_statement_begin__ = 696;
                for (int j = 1; j <= get_base1(D,6,"D",1); ++j) {
                    {
                    current_statement_begin__ = 697;
                    int ikf(0);
                    (void) ikf;  // dummy to suppress unused var warning

                    stan::math::fill(ikf, std::numeric_limits<int>::min());
                    stan::math::assign(ikf,(((1 + get_base1(D,3,"D",1)) + get_base1(D,5,"D",1)) + j));
                    current_statement_begin__ = 698;
                    local_scalar_t__ alp;
                    (void) alp;  // dummy to suppress unused var warning

                    stan::math::initialize(alp, DUMMY_VAR__);
                    stan::math::fill(alp,DUMMY_VAR__);
                    stan::math::assign(alp,get_base1(alpha_categOffset,j,"alpha_categOffset",1));


                    current_statement_begin__ = 699;
                    stan::math::assign(r, (r + 1));
                    current_statement_begin__ = 700;
                    stan::model::assign(KX, 
                                stan::model::cons_list(stan::model::index_uni(r), stan::model::nil_index_list()), 
                                multiply(square(alp),get_base1(KF,ikf,"KF",1)), 
                                "assigning variable KX");
                    }
                }
                current_statement_begin__ = 704;
                for (int j = 1; j <= sum_D; ++j) {

                    current_statement_begin__ = 705;
                    stan::math::assign(Kx, add(Kx, get_base1(KX,j,"KX",1)));
                }
                current_statement_begin__ = 709;
                stan::math::assign(Kx, add(Kx, diag_matrix(rep_vector(DELTA,n))));
                current_statement_begin__ = 712;
                stan::math::assign(Ky, add(Kx,diag_matrix(rep_vector(square(get_base1(sigma_n,1,"sigma_n",1)),n))));
                current_statement_begin__ = 713;
                stan::math::assign(Ly, cholesky_decompose(Ky));
                current_statement_begin__ = 716;
                stan::math::assign(v, mdivide_left_tri_low(Ly,y));
                current_statement_begin__ = 717;
                for (int j = 1; j <= sum_D; ++j) {

                    current_statement_begin__ = 718;
                    stan::math::assign(A, mdivide_left_tri_low(Ly,transpose(get_base1(KX,j,"KX",1))));
                    current_statement_begin__ = 719;
                    stan::model::assign(F_mean_cmp, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                multiply(transpose(A),v), 
                                "assigning variable F_mean_cmp");
                    current_statement_begin__ = 720;
                    stan::model::assign(F_var_cmp, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                diagonal(subtract(get_base1(KX,j,"KX",1),crossprod(A))), 
                                "assigning variable F_var_cmp");
                }
                current_statement_begin__ = 722;
                stan::math::assign(A, mdivide_left_tri_low(Ly,transpose(Kx)));
                current_statement_begin__ = 723;
                stan::model::assign(F_mean_tot, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            multiply(transpose(A),v), 
                            "assigning variable F_mean_tot");
                current_statement_begin__ = 724;
                stan::model::assign(F_var_tot, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            diagonal(subtract(Kx,crossprod(A))), 
                            "assigning variable F_var_tot");
                }
            }

            // validate generated quantities
            current_statement_begin__ = 631;
            current_statement_begin__ = 632;
            current_statement_begin__ = 633;
            current_statement_begin__ = 634;

            // write generated quantities
            for (int k_2__ = 0; k_2__ < n; ++k_2__) {
                for (int k_1__ = 0; k_1__ < sum_D; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < (1 - F_is_sampled); ++k_0__) {
                    vars__.push_back(F_mean_cmp[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_2__ = 0; k_2__ < n; ++k_2__) {
                for (int k_1__ = 0; k_1__ < sum_D; ++k_1__) {
                    for (int k_0__ = 0; k_0__ < (1 - F_is_sampled); ++k_0__) {
                    vars__.push_back(F_var_cmp[k_0__][k_1__][k_2__]);
                    }
                }
            }
            for (int k_1__ = 0; k_1__ < n; ++k_1__) {
                for (int k_0__ = 0; k_0__ < (1 - F_is_sampled); ++k_0__) {
                vars__.push_back(F_mean_tot[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < n; ++k_1__) {
                for (int k_0__ = 0; k_0__ < (1 - F_is_sampled); ++k_0__) {
                vars__.push_back(F_var_tot[k_0__][k_1__]);
                }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_lgp";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= get_base1(D,1,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_idAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,2,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_sharedAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_diseaseAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,4,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_continuous" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,5,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_categAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,6,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_categOffset" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,1,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_idAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,2,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_sharedAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_diseaseAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,4,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_continuous" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,5,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_categAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "warp_steepness" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_n" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= n_tot; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= F_is_sampled; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "ETA" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(HMGNS,0); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "beta" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(UNCRT,1); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T_raw" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= UNCRT; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T_onset" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_2__ = 1; k_2__ <= n_tot; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= F_is_sampled; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "F" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }


        if (!include_gqs__) return;
        for (int k_2__ = 1; k_2__ <= n; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "F_mean_cmp" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= n; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "F_var_cmp" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_1__ = 1; k_1__ <= n; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "F_mean_tot" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= n; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "F_var_tot" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= get_base1(D,1,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_idAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,2,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_sharedAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_diseaseAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,4,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_continuous" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,5,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_categAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,6,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "alpha_categOffset" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,1,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_idAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,2,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_sharedAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_diseaseAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,4,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_continuous" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,5,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "lengthscale_categAge" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= get_base1(D,3,"D",1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "warp_steepness" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(LH,1)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "sigma_n" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_2__ = 1; k_2__ <= n_tot; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= F_is_sampled; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "ETA" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(LH,3)) || primitive_value(logical_eq(LH,0))); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(HMGNS,0); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "beta" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(UNCRT,1); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "T_raw" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            for (int k_1__ = 1; k_1__ <= N_cases; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= UNCRT; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T_onset" << '.' << k_0__ << '.' << k_1__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            for (int k_2__ = 1; k_2__ <= n_tot; ++k_2__) {
                for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                    for (int k_0__ = 1; k_0__ <= F_is_sampled; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "F" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }


        if (!include_gqs__) return;
        for (int k_2__ = 1; k_2__ <= n; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "F_mean_cmp" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_2__ = 1; k_2__ <= n; ++k_2__) {
            for (int k_1__ = 1; k_1__ <= sum_D; ++k_1__) {
                for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "F_var_cmp" << '.' << k_0__ << '.' << k_1__ << '.' << k_2__;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        for (int k_1__ = 1; k_1__ <= n; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "F_mean_tot" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= n; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (1 - F_is_sampled); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "F_var_tot" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
    }

}; // model

}

typedef model_lgp_namespace::model_lgp stan_model;


#endif
