// [[Rcpp::depends(StanHeaders)]]
// [[Rcpp::depends(rstan)]]
// [[Rcpp::depends(RcppEigen)]]
// [[Rcpp::depends(BH)]]
#include <stan/math/prim/mat/fun/Eigen.hpp>
#include <boost/integer/integer_log2.hpp>
// REMOVED #include <exporter.h> by dev-cpp.R 
#include <RcppEigen.h>
// Code generated by Stan version 2.21.0
#include <stan/model/standalone_functions_header.hpp>
namespace user_ab08d76ddfc2e17cc6d46f45c2370e27 { 
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using namespace stan::math;
typedef Eigen::Matrix<double, Eigen::Dynamic, 1> vector_d;
typedef Eigen::Matrix<double, 1, Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> matrix_d;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "unknown file name");
    reader.add_event(41, 39, "end", "unknown file name");
    return reader;
}
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
STAN_vectorsum(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& vecs,
                   const int& L, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 6;
        int num_vecs(0);
        (void) num_vecs;  // dummy to suppress unused var warning
        stan::math::fill(num_vecs, std::numeric_limits<int>::min());
        stan::math::assign(num_vecs,size(vecs));
        current_statement_begin__ = 7;
        validate_non_negative_index("s", "L", L);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> s(L);
        stan::math::initialize(s, DUMMY_VAR__);
        stan::math::fill(s, DUMMY_VAR__);
        stan::math::assign(s,rep_vector(0, L));
        current_statement_begin__ = 8;
        for (int j = 1; j <= num_vecs; ++j) {
            current_statement_begin__ = 9;
            stan::math::assign(s, add(s, get_base1(vecs, j, "vecs", 1)));
        }
        current_statement_begin__ = 11;
        return stan::math::promote_scalar<fun_return_scalar_t__>(s);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct STAN_vectorsum_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& vecs,
                   const int& L, std::ostream* pstream__) const {
        return STAN_vectorsum(vecs, L, pstream__);
    }
};
template <typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
STAN_log_prior(const T0__& x,
                   const std::vector<int>& types,
                   const std::vector<T2__>& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 15;
        local_scalar_t__ log_prior(DUMMY_VAR__);
        (void) log_prior;  // dummy to suppress unused var warning
        stan::math::initialize(log_prior, DUMMY_VAR__);
        stan::math::fill(log_prior, DUMMY_VAR__);
        stan::math::assign(log_prior,0);
        current_statement_begin__ = 16;
        local_scalar_t__ t(DUMMY_VAR__);
        (void) t;  // dummy to suppress unused var warning
        stan::math::initialize(t, DUMMY_VAR__);
        stan::math::fill(t, DUMMY_VAR__);
        stan::math::assign(t,x);
        current_statement_begin__ = 19;
        if (as_bool(logical_eq(get_base1(types, 2, "types", 1), 1))) {
            current_statement_begin__ = 20;
            stan::math::assign(log_prior, (log_prior + stan::math::log(stan::math::fabs((2 * x)))));
            current_statement_begin__ = 21;
            stan::math::assign(t, square(x));
        }
        current_statement_begin__ = 25;
        if (as_bool(logical_eq(get_base1(types, 1, "types", 1), 2))) {
            current_statement_begin__ = 26;
            stan::math::assign(log_prior, (log_prior + normal_log(t, get_base1(p, 1, "p", 1), get_base1(p, 2, "p", 1))));
        } else if (as_bool(logical_eq(get_base1(types, 1, "types", 1), 3))) {
            current_statement_begin__ = 28;
            stan::math::assign(log_prior, (log_prior + student_t_log(t, get_base1(p, 1, "p", 1), 0.0, 1.0)));
        } else if (as_bool(logical_eq(get_base1(types, 1, "types", 1), 4))) {
            current_statement_begin__ = 30;
            stan::math::assign(log_prior, (log_prior + gamma_log(t, get_base1(p, 1, "p", 1), get_base1(p, 2, "p", 1))));
        } else if (as_bool(logical_eq(get_base1(types, 1, "types", 1), 5))) {
            current_statement_begin__ = 32;
            stan::math::assign(log_prior, (log_prior + inv_gamma_log(t, get_base1(p, 1, "p", 1), get_base1(p, 2, "p", 1))));
        } else if (as_bool(logical_eq(get_base1(types, 1, "types", 1), 6))) {
            current_statement_begin__ = 34;
            stan::math::assign(log_prior, (log_prior + lognormal_log(t, get_base1(p, 1, "p", 1), get_base1(p, 2, "p", 1))));
        }
        current_statement_begin__ = 37;
        return stan::math::promote_scalar<fun_return_scalar_t__>(log_prior);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct STAN_log_prior_functor__ {
    template <typename T0__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T2__>::type
    operator()(const T0__& x,
                   const std::vector<int>& types,
                   const std::vector<T2__>& p, std::ostream* pstream__) const {
        return STAN_log_prior(x, types, p, pstream__);
    }
};
 } 
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic, 1>
STAN_vectorsum(const std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> >& vecs,
                   const int& L, std::ostream* pstream__ = 0){
  return 
user_ab08d76ddfc2e17cc6d46f45c2370e27::STAN_vectorsum<double>(vecs, L, pstream__);
}
// [[Rcpp::export]]
double
STAN_log_prior(const double& x,
                   const std::vector<int>& types,
                   const std::vector<double>& p, std::ostream* pstream__ = 0){
  return 
user_ab08d76ddfc2e17cc6d46f45c2370e27::STAN_log_prior<double, double>(x, types, p, pstream__);
}
