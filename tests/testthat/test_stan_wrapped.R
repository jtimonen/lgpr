library(lgpr)

# -------------------------------------------------------------------------

context("Functions that wrap RcppExported cpp code generated by STAN")

test_that("cpp_warp_input works for scalar input", {
  w <- cpp_warp_input(-1, 1.32)
  expect_equal(w, -0.5783634)
})

test_that("cpp_warp_input works for vector input", {
  w <- cpp_warp_input(c(-1, 0, 1), 1.32)
  w_correct <- c(-0.5783634, 0.0, 0.5783634)
  expect_equal(w, w_correct)
})

test_that("cpp_warp_input errors with invalid steepness input", {
  expect_error(cpp_warp_input(1, -1))
  expect_error(cpp_warp_input(1, 0.0))
  expect_error(cpp_warp_input(1, NaN))
  expect_error(cpp_warp_input(1, Inf))
})

test_that("cpp_warp_input works similarly as reference", {
  a <- exp(stats::rnorm(1)) # random steepness
  x <- seq(-3, 3, by = 1.33)
  expect_equal(
    cpp_warp_input(x, a),
    sim_warp_input(x, a, 0, 1)
  )
})

test_that("cpp_var_mask works for scalar input", {
  m <- cpp_var_mask(-1, 1.32)
  expect_equal(m, 0.2108183)
})

test_that("cpp_var_mask works for vector input", {
  m <- cpp_var_mask(c(-1, 0, 1), 1.32)
  m_correct <- c(0.2108183, 0.5, 0.7891817)
  expect_equal(m, m_correct)
})

test_that("cpp_var_mask errors with invalid steepness input", {
  expect_error(cpp_var_mask(1, -1))
  expect_error(cpp_var_mask(1, 0.0))
  expect_error(cpp_var_mask(1, NaN))
  expect_error(cpp_var_mask(1, Inf))
})

test_that("cpp_var_mask works similarly as reference", {
  a <- 0.6
  x <- c(-5, 0, 5)
  expect_equal(
    cpp_var_mask(x, a),
    sim_var_mask(x, a)
  )
})

# -------------------------------------------------------------------------

# Model
m <- create_model(y ~ zs(id) * gp(age) + het(id) * gp_vm(dis_age) +
  categ(sex) + gp(age) + gp(blood),
data = testdata_001
)

# Input
input <- m@stan_input
x_cat <- input$x_cat
x_mask <- input$x_cont_mask
num_levels <- input$x_cat_num_levels
comp <- input$components
n <- dim(x_cat)[2]
K_const <- cpp_kernel_const_all(
  n, n, x_cat, x_cat, x_mask, x_mask,
  num_levels, comp
)

# Params
alpha <- c(1, 1, 1, 1, 1)
ell <- c(1, 1, 1, 1)
beta <- c(0.5, 1.0)
x <- input$x_cont
x_unnorm <- input$x_cont_unnorm
vm_params <- input$vm_params
ix <- input$idx_expand

# All kernels
teff_zero <- dollar(input, "teff_zero")
K <- cpp_kernel_all(
  n, n, K_const, comp, x, x, x_unnorm, x_unnorm,
  alpha, ell, 0.5, beta, NaN,
  vm_params, ix, ix, teff_zero
)

test_that("kernel_const_all works correctly", {
  expect_equal(length(K_const), 5)
  expect_equal(dim(K_const[[1]]), c(24, 24))
  S1 <- sum(K_const[[1]])
  expect_lt(abs(S1), 1e-6)
  expect_equal(sum(K_const[[4]]), 24 * 24)
  expect_equal(sum(K_const[[5]]), 24 * 24)
})

test_that("kernel_all works correctly", {
  expect_equal(length(K), 5)
  expect_equal(dim(K[[1]]), c(24, 24))
})

test_that("gp_posterior works correctly", {
  y <- testdata_001$y
  fp <- cpp_gp_posterior(K, K, K, y, 1e-6, 1.0)
  expect_equal(length(fp), 12)

  # test that component-wise means sum to total mean
  f_sum <- fp[[1]]
  for (j in 2:5) {
    f_sum <- f_sum + fp[[j]]
  }
  diff <- f_sum - fp[[6]]
  expect_lt(max(abs(diff)), 1e-6)
})


# -------------------------------------------------------------------------

# Model
m <- create_model(y ~ age + sex, testdata_001)

# Input
input <- m@stan_input
x_cat <- input$x_cat
x_mask <- input$x_cont_mask
num_levels <- input$x_cat_num_levels
comp <- input$components
n <- dim(x_cat)[2]
K_const <- cpp_kernel_const_all(
  n, n, x_cat, x_cat, x_mask, x_mask,
  num_levels, comp
)

# Params
alpha <- c(1, 1)
ell <- c(1)
x <- input$x_cont
x_unnorm <- input$x_cont_unnorm
vm_params <- input$vm_params
ix <- input$idx_expand

# All kernels
teff_zero <- dollar(input, "teff_zero")
K <- cpp_kernel_all(
  n, n, K_const, comp, x, x, x_unnorm, x_unnorm,
  alpha, ell, NaN, NaN, NaN,
  vm_params, ix, ix, teff_zero
)

test_that("kernel_const_all works when no nonstationary components", {
  expect_equal(length(K_const), 2)
})

test_that("kernel_all works when no nonstationary components", {
  expect_equal(length(K), 2)
})
