#' Simulate latent function components for longitudinal data analysis
#'
#' @param X input data matrix (generated by \code{\link{create_X}})
#' @param covariates Integer vector that defines the types of covariates
#' (other than id and age). Different integers correspond to the
#' following covariate types:
#' \itemize{
#'   \item 0 = disease-related age
#'   \item 1 = other continuous covariate
#'   \item 2 = a categorical covariate that interacts with age
#'   \item 3 = a categorical covariate that acts as a group offset
#' }
#' @param relevances Relative relevance of each component. Must have be a vector
#' so that \cr
#'  \code{length(relevances) =  2 + length(covariates)}. \cr
#' First two values define the relevance of the infividual-specific age and 
#' shared age component, respectively.
#' @param lengthscales A vector so that \cr \code{length(lengthscales) = }
#' \code{2 + sum(covariates \%in\% c(0,1,2))}.
#' @param X_affected which individuals are affected by the disease
#' @param dis_fun A function that defines the disease effect. If NULL, the effect
#' is is drawn from a nonstationary GP prior.
#' @param useBinKernel Should the binary kernel be used for categorical covariates? 
#' If this is \code{TRUE}, the effect will exist only for group 1.
#' @return a data frame FFF where one column corresponds to one additive data component
create_F <- function(X,
                     covariates,
                     relevances,
                     lengthscales,
                     X_affected,
                     dis_fun,
                     useBinKernel = TRUE)
{
  D     <- c(1, 2, covariates + 3)
  KK    <- simulate_kernels(X, D, lengthscales, X_affected, useBinKernel)
  labs  <- nameComponents(D, colnames(X))
  FFF   <- drawLatentComponents(KK)
  if(sum(D==3)==1 && !is.null(dis_fun)){
    icol <- which(labs=="diseaseAge")
    FFF[,icol] <- disease_effect(X[,1],X[,3],dis_fun)
  }
  FFF   <- scaleRelevances(FFF, relevances)
  colnames(FFF) <- labs
  return(data.frame(FFF))
}


#' Compute all kernel matrices when simulating data
#'
#' @param X covariates
#' @param types vector of covariate types, so that
#' \itemize{
#'   \item 1 = ID
#'   \item 2 = age
#'   \item 3 = diseaseAge
#'   \item 4 = other continuous covariate
#'   \item 5 = a categorical covariate that interacts with age
#'   \item 6 = a categorical covariate that acts as an offset
#' }
#' @param lengthscales vector of lengthscales
#' @param X_affected which individuals are affected by the disease
#' @param useBinKernel whether or not binary (mask) kernel should be used for
#' categorical covariates
#' @return a 3D array
simulate_kernels <- function(X, types, lengthscales, X_affected, useBinKernel=TRUE){
  n     <- dim(X)[1]
  d     <- length(types)
  KK    <- array(0,c(n,n,d))
  t     <- X[,which(types==2)]
  id    <- X[,which(types==1)]
  n_ell <- sum(types!=6)
  d_ell <- length(lengthscales)
  if(d_ell != n_ell){
    stop("lengthscales has length ", d_ell, ", should be ", n_ell)
  }
  j_ell <- 0
  ell <- lengthscales
  for(j in 1:d){
    xj <- X[,j]
    if(types[j]==1){
      j_ell <- j_ell + 1
      Kj <- kernel_cat(id,id)*kernel_se(t,t,ell=ell[j_ell])
    }else if(types[j]==2){
      j_ell <- j_ell + 1
      Kj <- kernel_se(t,t,ell=ell[j_ell])
    }else if(types[j]==3){
      j_ell <- j_ell + 1
      Kj <- kernel_bin(X_affected, X_affected) * kernel_ns(xj,xj,ell=ell[j_ell], a = 1, b = 0, c = 1)
    }else if(types[j]==4){
      j_ell <- j_ell + 1
      Kj <- kernel_se(xj,xj,ell=ell[j_ell])
    }else if(types[j]==5){
      j_ell <- j_ell + 1
      if(useBinKernel){
        Kj <- kernel_bin(xj,xj)*kernel_se(t,t,ell=ell[j_ell])
      }else{
        Kj <- kernel_cat(xj,xj)*kernel_se(t,t,ell=ell[j_ell])
      }
    }else if(types[j]==6){
      if(useBinKernel){
        Kj <- kernel_bin(xj,xj)
      }else{
        Kj <- kernel_cat(xj,xj)
      }
    }else{
      stop('types contains invalid values')
    }
    KK[,,j] <- Kj
  }
  return(KK)
}

#' Create names for all components based on covariate names and types
#'
#' @param types vector of covariate types
#' @param names names of the covariates
#' @return a vector of component names
nameComponents <- function(types,names){
  d    <- length(types)
  iAge <- which(types==1)
  componentNames <- rep("foo",d)
  for(j in 1:d){
    if(types[j]==1){
      lab <- "id*age"
    }else if(types[j]==5){
      lab <- paste(names[j], "*age",sep="")
    }else{
      lab <- names[j]
    }
    componentNames[j] <- lab
  }
  return(componentNames)
}


#' Scale the effect sizes
#'
#' @param FFF matrix where one column corresponds to one additive data component
#' @param f_var variance to which \code{FFF} will be scaled
#' @param relevances the desired variance of each component (column)
#' @param force_zero_mean should each component be forced to have zero mean?
#' @return a new matrix \code{FFF}
scaleRelevances <- function(FFF, relevances, f_var, force_zero_mean = TRUE){
  
  # Some input checking
  d <- dim(FFF)[2]
  R <- sum(relevances)
  if(any(relevances < 0)){
    stop("negative relevances not allowed!")
  }
  
  multip <- 1
  if(R==0){
    if(f_var !=0){
      stop("cannot set f_var different from zero if all relevances are zero")
    }else{
      multip <- 0
    }
  }
  
  # Scale the columns to correct relevances
  for(j in 1:d){
    std <- stats::sd(FFF[,j])
    if(std > 0){
      FFF[,j] <- multip*sqrt(relevances[j])/std*FFF[,j]
      if(force_zero_mean){
        FFF[,j] <- FFF[,j] - mean(FFF[,j])
      }
    }
  }
  return(FFF)
}


#' Draw realizations of multivariate normals
#'
#' @param KK 3D matrix where \code{KK[,,j]} is the \code{j}th kernel matrix
#' @return a matrix \code{FFF}
drawLatentComponents <- function(KK){
  n   <- dim(KK)[1]
  d   <- dim(KK)[3]
  mu0 <- rep(0,n)
  FFF <- matrix(0,n,d)
  for(j in 1:d){
    K  <- KK[,,j]
    fj <- MASS::mvrnorm(1, mu0, K)
    FFF[,j] <- fj
  }
  return(FFF)
}

#' Draw disease component from a parameteric form
#'
#' @param X_id the id covariate
#' @param X_disAge the diseaseAge covariate
#' @param dis_fun the disease age effect function
#' @return a vector
disease_effect <- function(X_id, X_disAge, dis_fun){
  n        <- length(X_id)
  uid      <- unique(X_id)
  F_disAge <- rep(0, n)
  for(id in uid){
    inds <- which(X_id==id)
    da <- X_disAge[inds]
    if(!is.nan(da[1])){
      F_disAge[inds] <- dis_fun(da)
    }
  }
  return(F_disAge)
}
